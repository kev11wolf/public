<!DOCTYPE html> <!-- Defines document type for HTML5 -->
<html lang="en"> <!-- Language set to English -->
<head> <!-- Head section: metadata, CSS, etc. -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>P6 Offline Viewer (Spin-off)</title> <!-- Page title -->

  <!-- Bootstrap 5 CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />
  <!-- PapaParse for CSV -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <!-- Bootstrap Icons (optional) -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css"
  />

  <style>
    /*
      Neutral light theme, plus dark mode overrides.
    */
    :root {
      --primary-color: #222831;
      --secondary-color: #393E46;
      --accent-color: #9CA3AF;
      --bg-color: #EEEEEE;
      --white-color: #FFFFFF;

      --dark-background: #121212;
      --dark-card-bg: #1E1E1E;
      --dark-text-color: #E0E0E0;
      --hover-color: #E5E7EB;
    }

    body.dark-mode {
      background-color: var(--dark-background);
      color: var(--dark-text-color);
    }
    body.dark-mode .navbar {
      background-color: var(--dark-card-bg) !important;
    }
    body.dark-mode .card {
      background-color: var(--dark-card-bg) !important;
      color: var(--dark-text-color) !important;
    }
    body.dark-mode .table-hover tbody tr:hover {
      background-color: #333 !important;
    }
    body.dark-mode .table-light {
      background-color: #2C2C2C !important;
      color: var(--dark-text-color) !important;
    }
    body.dark-mode .spinner-border.text-secondary {
      color: var(--dark-text-color) !important;
    }
    body.dark-mode .bg-primary,
    body.dark-mode .bg-warning,
    body.dark-mode .bg-success,
    body.dark-mode .bg-info,
    body.dark-mode .bg-dark {
      background-color: #2C2C2C !important;
      color: var(--dark-text-color) !important;
    }
    body.dark-mode .btn,
    body.dark-mode .btn-sm {
      color: var(--dark-text-color) !important;
    }
    body.dark-mode .activity-card:hover {
      background-color: #333 !important;
    }

    body {
      background-color: var(--bg-color);
      font-size: 0.9rem;
      transition: background-color 0.2s ease, color 0.2s ease;
    }
    .navbar {
      margin-bottom: 1rem;
      background-color: var(--primary-color) !important;
    }
    .navbar-brand {
      color: var(--white-color) !important;
    }

    .card {
      width: 90vw;
      margin: 0 auto;
      margin-bottom: 1rem;
      border: none;
      border-radius: 8px;
      transition: background-color 0.2s ease, color 0.2s ease;
    }
    .card-body {
      padding: 0.75rem;
      background-color: var(--white-color);
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
      transition: background-color 0.2s ease, color 0.2s ease;
    }
    .card-header {
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      transition: background-color 0.2s ease, color 0.2s ease;
    }

    .log-container {
      max-height: 150px;
      overflow-y: auto;
      background: #f1f1f1;
      padding: 8px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 0.8rem;
    }

    .activity-card {
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .activity-card:hover {
      background-color: var(--hover-color);
    }

    .btn:hover,
    .filter-input:hover {
      opacity: 0.95;
    }

    .search-results {
      max-height: 200px;
      overflow-y: auto;
    }

    .relation-table {
      table-layout: fixed;
      width: 100%;
      max-width: 100%;
      cursor: pointer;
    }
    .relation-table th,
    .relation-table td {
      font-size: 0.8rem;
      padding: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      transition: background-color 0.2s ease;
    }
    .relation-table th:nth-child(1),
    .relation-table td:nth-child(1) {
      width: 50px;
    }
    .relation-table th:nth-child(2),
    .relation-table td:nth-child(2) {
      width: 200px;
    }
    .relation-table th:nth-child(3),
    .relation-table td:nth-child(3) {
      width: 50px;
    }
    .relation-table th:nth-child(4),
    .relation-table td:nth-child(4) {
      width: 50px;
    }
    .relation-table th:nth-child(5),
    .relation-table td:nth-child(5) {
      width: 50px;
    }
    .relation-table th:nth-child(6),
    .relation-table td:nth-child(6) {
      width: 50px;
    }
    .relation-table th:nth-child(7),
    .relation-table td:nth-child(7) {
      width: 50px;
    }
    .relation-table th:nth-child(8),
    .relation-table td:nth-child(8) {
      width: 50px;
    }
    .relation-table th:nth-child(9),
    .relation-table td:nth-child(9) {
      width: 50px;
    }
    .relation-table th:nth-child(10),
    .relation-table td:nth-child(10) {
      width: 50px;
    }
    .relation-table th:nth-child(11),
    .relation-table td:nth-child(11) {
      width: 50px;
    }

    .filter-input {
      width: 100%;
      margin-bottom: 6px;
      font-size: 0.8rem;
    }

    #csvLoadingSpinner {
      display: none;
    }

    .type-start-milestone,
    .type-finish-milestone,
    .type-loe {
      background-color: #d3d3d3 !important;
    }
    .type-task-dependent {
      background-color: #d2f2d2 !important;
    }
  </style>
</head>
<body>
  <!-- Navbar -->
  <nav class="navbar navbar-expand-lg navbar-dark" style="background-color: var(--primary-color);">
    <div class="container-fluid">
      <!-- Logo -->
      <svg
        style="max-height: 40px; margin-right: 8px;"
        viewBox="0 0 24 24"
        fill="white"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M19 3H18V1H16V3H8V1H6V3H5C3.897 3 3 3.897 3 5V21C3 22.103 3.897 23 5 23H19C20.103 23 21 22.103 21 21V5C21 3.897 20.103 3 19 3ZM19 21H5V8H19V21Z"
        />
      </svg>
      <span class="navbar-brand" style="padding-top: 0;">P6 Offline Viewer</span>

      <!-- Right side buttons -->
      <div class="ms-auto d-flex align-items-center">
        <button id="aboutBtn" class="btn btn-secondary btn-sm me-2">
          <i class="bi bi-info-circle"></i>
          About
        </button>
        <button id="darkModeBtn" class="btn btn-danger btn-sm">
          Dark Mode
        </button>
      </div>
    </div>
  </nav>

  <!-- Main layout (single column) -->
  <div class="row g-3">
    <div class="col-12">
      <!-- 1) Upload Section -->
      <div class="card shadow-sm">
        <div class="card-header bg-primary text-white">
          <h6 class="mb-0">1. Upload Schedule (CSV)</h6>
        </div>
        <div class="card-body">
          <!-- CSV file input -->
          <input
            type="file"
            id="csvUpload"
            accept=".csv"
            class="form-control form-control-sm"
          />
          <small class="text-muted">
            Headers: Activity ID, Activity Name, Start, Finish, Predecessors, Predecessor Details, etc.
          </small>
          <!-- Spinner while parsing -->
          <div id="csvLoadingSpinner" class="text-center my-2">
            <div class="spinner-border text-secondary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <p class="small text-muted">Parsing CSV data...</p>
          </div>
        </div>
      </div>

      <!-- 2) Search for an Activity -->
      <div class="card shadow-sm" id="searchSection" style="visibility:hidden;">
        <div class="card-header bg-success text-white">
          <h6 class="mb-0">2. Search for an Activity</h6>
        </div>
        <div class="card-body">
          <!-- Search bar for activity -->
          <input
            type="text"
            id="activitySearch"
            class="form-control form-control-sm mb-2"
            placeholder="Search ID or Name..."
          />
          <div id="searchResults" class="search-results border p-2 bg-white small"></div>
        </div>
      </div>

      <!-- 3) Critical Path Tracer -->
      <div class="card shadow-sm" id="cpTracer" style="visibility:hidden;">
        <div class="card-header bg-info text-white">
          <h6 class="mb-0">3. Critical Path Tracer</h6>
        </div>
        <div class="card-body">
          <table class="table table-sm table-hover" id="cpTable">
            <thead class="table-light">
              <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Start</th>
                <th>Finish</th>
                <th>Status</th>
                <th>Total Float</th>
                <th>Rel FF</th> <!-- Relationship Free Float column -->
                <th></th> <!-- remove button column -->
              </tr>
            </thead>
            <tbody id="cpTableBody"></tbody>
          </table>
          <button id="clearCPBtn" class="btn btn-warning btn-sm">Clear CP</button>
          <button id="resetCPBtn" class="btn btn-secondary btn-sm">Reset to Start</button>
        </div>
      </div>

      <!-- 4) Predecessors & Successors -->
      <div class="card shadow-sm" id="detailSection" style="visibility:hidden;">
        <div class="card-header bg-warning text-dark">
          <h6 class="mb-0">4. View Predecessors & Successors</h6>
        </div>
        <div class="card-body">
          <!-- Predecessors Table -->
          <h6>Predecessors</h6>
          <input
            type="text"
            placeholder="Filter Predecessors..."
            class="filter-input"
            id="predFilter"
          />
          <div id="predecessorList"></div>

          <!-- Successors Table -->
          <h6 class="mt-3">Successors</h6>
          <input
            type="text"
            placeholder="Filter Successors..."
            class="filter-input"
            id="succFilter"
          />
          <div id="successorList"></div>
        </div>
      </div>

      <!-- Log card -->
      <div class="card shadow-sm" id="logCard">
        <div class="card-header bg-dark text-white">
          <h6 class="mb-0">Log</h6>
        </div>
        <div class="card-body p-0">
          <pre id="log" class="log-container m-0 p-2"></pre>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap Bundle JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <!-- Main Script -->
  <script>
    // -------------------------------------------------------------
    // Global Variables
    // -------------------------------------------------------------
    let activities = [];           // From CSV
    let activityMap = {};          // Map (ID -> object)
    let selectedActivity = null;   // Currently selected
    let criticalPath = [];         // Array of CP chain

    // Sorting configs
    let sortState = {
      pred: { field: 'Finish', asc: false, relFFMode: 0 },
      succ: { field: 'Finish', asc: false, relFFMode: 0 }
    };

    // DOM references
    const csvUpload = document.getElementById('csvUpload');
    const searchSection = document.getElementById('searchSection');
    const detailSection = document.getElementById('detailSection');
    const cpTracer = document.getElementById('cpTracer');
    const activitySearch = document.getElementById('activitySearch');
    const searchResults = document.getElementById('searchResults');
    const predecessorList = document.getElementById('predecessorList');
    const successorList = document.getElementById('successorList');
    const predFilter = document.getElementById('predFilter');
    const succFilter = document.getElementById('succFilter');
    const log = document.getElementById('log');
    const csvLoadingSpinner = document.getElementById('csvLoadingSpinner');
    const cpTableBody = document.getElementById('cpTableBody');
    const clearCPBtn = document.getElementById('clearCPBtn');
    const resetCPBtn = document.getElementById('resetCPBtn');
    const aboutBtn = document.getElementById('aboutBtn');
    const darkModeBtn = document.getElementById('darkModeBtn');

    // -------------------------------------------------------------
    // Utility / Logging
    // -------------------------------------------------------------
    // Log helper
    function addLog(message, tip = '') {
      const timestamp = new Date().toLocaleTimeString();
      const logLine = tip
        ? `[${timestamp}] ${message}\n TIP: ${tip}\n`
        : `[${timestamp}] ${message}\n`;
      log.innerHTML += logLine;
      log.scrollTop = log.scrollHeight;
    }

    // Clean P6 date string
    function cleanDate(dateStr) {
      if (!dateStr) return '';
      return dateStr.replace(/ A/g, '').replace(/\*/g, '').trim();
    }

    // Convert string -> Date
    function parseDate(dateStr) {
      if (!dateStr) return null;
      const d = new Date(dateStr);
      return isNaN(d.getTime()) ? null : d;
    }

    // Validate CSV
    function validateColumns(data) {
      const required = [
        'Activity ID',
        'Start',
        'Finish',
        'Predecessors',
        'Predecessor Details'
      ];
      if (data.length === 0) {
        addLog('No data found in CSV.', 'Please check file and try again.');
        alert('CSV is empty.');
        return false;
      }
      const firstRow = Object.keys(data[0]);
      const missing = required.filter(col => !firstRow.includes(col));
      if (missing.length > 0) {
        addLog(`Missing columns: ${missing.join(', ')}`, 'Check CSV format.');
        alert('Some required columns are missing: ' + missing.join(', '));
        return false;
      }
      return true;
    }

    // Parse rel type from Predecessor Details
    function parseRelationshipType(sourceAct, targetID) {
      const detailStr = sourceAct['Predecessor Details'] || '';
      const chunks = detailStr.split(';').map(x => x.trim()).filter(Boolean);
      for (const c of chunks) {
        const parts = c.split(':').map(x => x.trim());
        if (parts.length >= 2) {
          const pID = parts[0];
          const rel = parts[1];
          if (pID === targetID) {
            return rel;
          }
        }
      }
      return '—';
    }

    // 3-mode sorting for Rel FF
    function customSortRelFF(arr, col, mode) {
      arr.sort((a, b) => {
        const valA = parseFloat(a[col]) || 0;
        const valB = parseFloat(b[col]) || 0;
        // 0 => ascending
        if (mode === 0) return valA - valB;
        // 1 => descending
        if (mode === 1) return valB - valA;
        // 2 => distance from zero
        const distA = Math.abs(valA);
        const distB = Math.abs(valB);
        return distA - distB;
      });
    }

    // Generic sort
    function sortActivities(arr, field, ascending, relFFMode = 0) {
      if (field === 'Rel FF') {
        customSortRelFF(arr, 'Rel FF', relFFMode);
        return;
      }
      arr.sort((a, b) => {
        const valA = (a[field] || '').toLowerCase();
        const valB = (b[field] || '').toLowerCase();

        // total float numeric
        if (field === 'Total Float') {
          const numA = parseFloat(valA) || 0;
          const numB = parseFloat(valB) || 0;
          return ascending ? numA - numB : numB - numA;
        }
        // date compare
        if (field === 'Start' || field === 'Finish') {
          const dateA = parseDate(valA) || 0;
          const dateB = parseDate(valB) || 0;
          return ascending ? dateA - dateB : dateB - dateA;
        }
        // fallback string
        if (valA < valB) return ascending ? -1 : 1;
        if (valA > valB) return ascending ? 1 : -1;
        return 0;
      });
    }

    // Filter on object values
    function filterActivities(arr, query) {
      if (!query) return arr;
      const q = query.toLowerCase();
      return arr.filter(act => {
        return Object.values(act).some(val => {
          if (!val) return false;
          return val.toString().toLowerCase().includes(q);
        });
      });
    }

    // Row class by type
    function getRowClassByType(actType) {
      if (!actType) return '';
      const lower = actType.toLowerCase();
      if (lower.includes('start milestone') || lower.includes('finish milestone') || lower.includes('loe')) {
        return 'type-loe';
      }
      if (lower.includes('task dependent')) {
        return 'type-task-dependent';
      }
      return '';
    }

    // Float shading
    function getFloatShading(tf, minTF, maxTF) {
      if (minTF === maxTF) return '';
      const val = parseFloat(tf);
      if (isNaN(val)) return '';
      let ratio = (val - minTF) / (maxTF - minTF);
      ratio = 1 - ratio;
      const R = 255;
      const G = Math.floor(255 - 255 * ratio);
      const B = Math.floor(255 - 255 * ratio);
      return `rgb(${R}, ${G}, ${B}, 0.7)`;
    }

    // Quick date validity check
    function isValidDate(d) {
      return d instanceof Date && !isNaN(d);
    }

    // -------------------------------------------------------------
    // Relationship Free Float Calculation
    // -------------------------------------------------------------
    /**
     * Compute 'Rel FF' = (currentAct dates) - (predecessorAct dates),
     * applying your custom logic for tasks vs. milestones vs. LOE.
     */
    function computeRelationshipFreeFloat(currentAct, predAct) {
      const MS_PER_DAY = 1000 * 3600 * 24;

      // Type checks
      const currType = (currentAct['Activity Type'] || '').toLowerCase();
      const predType = (predAct['Activity Type'] || '').toLowerCase();

      // Convert dates
      const currStart = parseDate(currentAct['Start']);
      const currFinish = parseDate(currentAct['Finish']);
      const predStart = parseDate(predAct['Start']);
      const predFinish = parseDate(predAct['Finish']);

      // LOE => N/A
      if (currType.includes('loe') || predType.includes('loe')) {
        return 'N/A';
      }

      // Both finish milestones => use finish - finish
      if (currType.includes('finish milestone') && predType.includes('finish milestone')) {
        if (!isValidDate(currFinish) || !isValidDate(predFinish)) {
          return '0.0';
        }
        const diff = (currFinish - predFinish) / MS_PER_DAY;
        return diff.toFixed(1);
      }

      // Both start milestones => start - start
      if (currType.includes('start milestone') && predType.includes('start milestone')) {
        if (!isValidDate(currStart) || !isValidDate(predStart)) {
          return '0.0';
        }
        const diff = (currStart - predStart) / MS_PER_DAY;
        return diff.toFixed(1);
      }

      // Current = finish milestone, predecessor = task dependent
      if (currType.includes('finish milestone') && predType.includes('task dependent')) {
        if (!isValidDate(currFinish) || !isValidDate(predFinish)) {
          return '0.0';
        }
        const diff = (currFinish - predFinish) / MS_PER_DAY;
        return diff.toFixed(1);
      }

      // Current = start milestone, predecessor = task dependent
      if (currType.includes('start milestone') && predType.includes('task dependent')) {
        if (!isValidDate(currStart) || !isValidDate(predFinish)) {
          return '0.0';
        }
        const diff = (currStart - predFinish) / MS_PER_DAY;
        return diff.toFixed(1);
      }

      // Current = task dependent, predecessor = finish milestone
      if (currType.includes('task dependent') && predType.includes('finish milestone')) {
        if (!isValidDate(currStart) || !isValidDate(predFinish)) {
          return '0.0';
        }
        const diff = (currStart - predFinish) / MS_PER_DAY;
        return diff.toFixed(1);
      }

      // Current = task dependent, predecessor = start milestone
      if (currType.includes('task dependent') && predType.includes('start milestone')) {
        if (!isValidDate(currStart) || !isValidDate(predStart)) {
          return '0.0';
        }
        const diff = (currStart - predStart) / MS_PER_DAY;
        return diff.toFixed(1);
      }

      // Both are task dependent
      if (currType.includes('task dependent') && predType.includes('task dependent')) {
        if (!isValidDate(currStart) || !isValidDate(predFinish)) {
          return '0.0';
        }
        const diff = (currStart - predFinish) / MS_PER_DAY;
        return diff.toFixed(1);
      }

      // Fallback
      return 'N/A';
    }

    // -------------------------------------------------------------
    // CSV Upload
    // -------------------------------------------------------------
    csvUpload.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      addLog(`File selected: ${file.name}`, 'Wait for parsing...');
      csvLoadingSpinner.style.display = 'block';

      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        worker: true,
        complete: result => {
          csvLoadingSpinner.style.display = 'none';
          if (result.errors.length) {
            addLog(
              `Parse errors: ${result.errors.map(er => er.message).join('; ')}`,
              'Check CSV format.'
            );
            alert('CSV parse errors present. Check log.');
            return;
          }
          if (!validateColumns(result.data)) return;

          activities = result.data.map(act => ({
            ...act,
            'Start': cleanDate(act['Start']),
            'Finish': cleanDate(act['Finish'])
          }));
          activityMap = {};
          activities.forEach(act => {
            const idTrim = (act['Activity ID'] || '').trim();
            if (idTrim) {
              activityMap[idTrim] = act;
            }
          });
          addLog(`Loaded ${activities.length} activities.`, 'Search for an Activity (Step 2).');
          searchSection.style.visibility = 'visible';
          cpTracer.style.visibility = 'hidden';
          detailSection.style.visibility = 'hidden';
        },
        error: err => {
          csvLoadingSpinner.style.display = 'none';
          addLog(`Parse error: ${err}`, 'Check your CSV.');
          alert('Failed to parse CSV.');
        }
      });
    });

    // -------------------------------------------------------------
    // Searching
    // -------------------------------------------------------------
    activitySearch.addEventListener('input', () => {
      const query = activitySearch.value.trim().toLowerCase();
      searchResults.innerHTML = '';
      if (!query) return;

      const matches = activities.filter(act => {
        const idStr = (act['Activity ID'] || '').toLowerCase();
        const nameStr = (act['Activity Name'] || '').toLowerCase();
        return idStr.includes(query) || nameStr.includes(query);
      });

      if (!matches.length) {
        searchResults.innerHTML = '<div class="text-muted p-1">No matches found.</div>';
        return;
      }

      matches.forEach(act => {
        const div = document.createElement('div');
        div.className = 'activity-card p-1 border-bottom small';
        const idVal = act['Activity ID'] || 'N/A';
        const nameVal = act['Activity Name'] || 'N/A';
        div.innerHTML = `<strong>${idVal}</strong> - ${nameVal}`;
        div.onclick = () => {
          criticalPath = [act];
          selectedActivity = act;
          addLog(`New activity selected: ${act['Activity ID']}`, 'CP started fresh.');
          updateCPUI();
          searchResults.innerHTML = '';
          activitySearch.value = '';

          searchSection.style.visibility = 'visible';
          cpTracer.style.visibility = 'visible';
          detailSection.style.visibility = 'visible';

          showPredecessors(act);
          showSuccessors(act);
        };
        searchResults.appendChild(div);
      });

      addLog(`Search updated for "${query}".`);
    });

    // -------------------------------------------------------------
    // CP Tracer
    // -------------------------------------------------------------
    function updateCPUI() {
      cpTableBody.innerHTML = '';
      // For each activity in criticalPath, build a row
      criticalPath.forEach((cpAct, idx) => {
        const row = document.createElement('tr');
        const idVal = cpAct['Activity ID'] || '—';
        const nameVal = cpAct['Activity Name'] || '—';
        const startVal = cpAct['Start'] || '—';
        const finishVal = cpAct['Finish'] || '—';
        const statusVal = cpAct['Activity Status'] || '—';
        const tfVal = cpAct['Total Float'] || '—';

        // If it's not the first item, compute "Rel FF" with the same *direction* as the Predecessors logic
        let relFFVal = '—';
        if (idx > 0) {
          // The predecessor in the CP array = criticalPath[idx - 1]
          const predecessor = criticalPath[idx - 1];
          // Same call as in Predecessors: computeRelationshipFreeFloat(currentAct, predecessor)
          relFFVal = computeRelationshipFreeFloat(cpAct, predecessor);
        }

        row.innerHTML = `
          <td><strong>${idVal}</strong></td>
          <td>${nameVal}</td>
          <td>${startVal}</td>
          <td>${finishVal}</td>
          <td>${statusVal}</td>
          <td>${tfVal}</td>
          <td>${relFFVal}</td>
          <td>
            <button class="btn btn-sm btn-outline-danger" onclick="removeFromCP(${idx})">X</button>
          </td>
        `;
        const rowClass = getRowClassByType(cpAct['Activity Type'] || '');
        if (rowClass) {
          row.classList.add(rowClass);
        }
        cpTableBody.appendChild(row);
      });
    }

    // Provide a global remove function
    window.removeFromCP = function(index) {
      if (criticalPath[index]) {
        const removed = criticalPath.splice(index, 1);
        addLog(`Removed from CP: ${removed[0]['Activity ID']}`);
        updateCPUI();
        if (criticalPath.length > 0) {
          const lastAct = criticalPath[criticalPath.length - 1];
          selectedActivity = lastAct;
          showPredecessors(lastAct);
          showSuccessors(lastAct);
        } else {
          selectedActivity = null;
          predecessorList.innerHTML = '';
          successorList.innerHTML = '';
          detailSection.style.visibility = 'hidden';
        }
      }
    };

    clearCPBtn.addEventListener('click', () => {
      criticalPath = [];
      addLog('Cleared entire CP.', 'Select an activity again to start new path.');
      updateCPUI();
      selectedActivity = null;
      predecessorList.innerHTML = '';
      successorList.innerHTML = '';
      detailSection.style.visibility = 'hidden';
    });

    resetCPBtn.addEventListener('click', () => {
      if (selectedActivity) {
        criticalPath = [selectedActivity];
        addLog('Reset CP to current activity.', 'Re-add any needed predecessors.');
        updateCPUI();
        showPredecessors(selectedActivity);
        showSuccessors(selectedActivity);
      }
    });

    // Add predecessor into CP
    function addToCP(newAct) {
      const found = criticalPath.find(a => a['Activity ID'] === newAct['Activity ID']);
      if (!found) {
        criticalPath.push(newAct);
        addLog(`Added ${newAct['Activity ID']} to CP.`, 'Continuing path...');
        updateCPUI();
      }
    }

    // -------------------------------------------------------------
    // Predecessors
    // -------------------------------------------------------------
    function showPredecessors(currentAct) {
      predecessorList.innerHTML = '';
      const rawPreds = (currentAct['Predecessors'] || '').split(/[,;]/).map(s => s.trim()).filter(Boolean);
      let validPreds = rawPreds.filter(id => activityMap[id]);
      if (!validPreds.length) {
        predecessorList.innerHTML = '<p class="text-muted small">No predecessors.</p>';
        return;
      }

      let predArray = validPreds.map(pid => activityMap[pid]);

      // Filter
      const filterVal = predFilter.value.trim().toLowerCase();
      predArray = filterActivities(predArray, filterVal);

      // Compute Relationship Type & Rel FF
      predArray.forEach(predAct => {
        predAct['Relationship Type'] = parseRelationshipType(currentAct, predAct['Activity ID']);
        // same direction => (currentActivity, predecessorActivity)
        predAct['Rel FF'] = computeRelationshipFreeFloat(currentAct, predAct);
      });

      // Sort
      const field = sortState.pred.field;
      const asc = sortState.pred.asc;
      const relFFMode = sortState.pred.relFFMode;
      sortActivities(predArray, field, asc, relFFMode);

      const floats = predArray.map(p => parseFloat(p['Total Float']) || 0);
      const minTF = Math.min(...floats);
      const maxTF = Math.max(...floats);

      const table = document.createElement('table');
      table.className = 'table table-sm table-bordered relation-table table-hover';
      table.innerHTML = `
        <thead class="table-light">
          <tr>
            <th data-col="Activity ID">ID</th>
            <th data-col="Activity Name">Name</th>
            <th data-col="Start">Start</th>
            <th data-col="Finish">Finish</th>
            <th data-col="Activity Status">Status</th>
            <th data-col="Primary Constraint">Primary Constraint</th>
            <th data-col="Total Float">Total Float</th>
            <th data-col="Activity Type">Activity Type</th>
            <th data-col="Relationship Type">Rel Type</th>
            <th data-col="Rel FF">Rel FF</th>
          </tr>
        </thead>
        <tbody id="predTableBody"></tbody>
      `;
      const tbody = table.querySelector('#predTableBody');

      predArray.forEach(predAct => {
        const row = document.createElement('tr');
        row.className = 'activity-card';
        row.ondblclick = () => {
          addToCP(predAct);
          selectedActivity = predAct;
          showPredecessors(predAct);
          showSuccessors(predAct);
        };

        const idVal = predAct['Activity ID'] || '—';
        const nameVal = predAct['Activity Name'] || '—';
        const startVal = predAct['Start'] || '—';
        const finishVal = predAct['Finish'] || '—';
        const statusVal = predAct['Activity Status'] || '—';
        const pcVal = predAct['Primary Constraint'] || '—';
        const tfVal = predAct['Total Float'] || '—';
        const typeVal = predAct['Activity Type'] || '—';
        const relTypeVal = predAct['Relationship Type'] || '—';
        const relFFVal = predAct['Rel FF'] || 'N/A';

        const rowClass = getRowClassByType(typeVal);
        if (rowClass) {
          row.classList.add(rowClass);
        }

        row.innerHTML = `
          <td><strong>${idVal}</strong></td>
          <td>${nameVal}</td>
          <td>${startVal}</td>
          <td>${finishVal}</td>
          <td>${statusVal}</td>
          <td>${pcVal}</td>
          <td>${tfVal}</td>
          <td>${typeVal}</td>
          <td>${relTypeVal}</td>
          <td>${relFFVal}</td>
        `;

        const cellTF = row.querySelector('td:nth-child(7)');
        if (cellTF && tfVal !== '—') {
          cellTF.style.backgroundColor = getFloatShading(parseFloat(tfVal), minTF, maxTF);
        }

        tbody.appendChild(row);
      });

      predecessorList.appendChild(table);

      // Sort by clicks
      const headers = table.querySelectorAll('th[data-col]');
      headers.forEach(th => {
        th.addEventListener('click', () => {
          const col = th.getAttribute('data-col');
          if (col === 'Rel FF') {
            if (sortState.pred.field === 'Rel FF') {
              sortState.pred.relFFMode = (sortState.pred.relFFMode + 1) % 3;
            } else {
              sortState.pred.field = 'Rel FF';
              sortState.pred.relFFMode = 0;
            }
          } else {
            if (sortState.pred.field === col) {
              sortState.pred.asc = !sortState.pred.asc;
            } else {
              sortState.pred.field = col;
              sortState.pred.asc = true;
            }
          }
          showPredecessors(currentAct);
        });
      });
    }

    // -------------------------------------------------------------
    // Successors
    // -------------------------------------------------------------
    function showSuccessors(currentAct) {
      successorList.innerHTML = '';
      const currID = currentAct['Activity ID'] || '';
      const successors = activities.filter(act => {
        const rawPreds = (act['Predecessors'] || '').split(/[,;]/).map(s => s.trim());
        return rawPreds.includes(currID);
      });
      if (!successors.length) {
        successorList.innerHTML = '<p class="text-muted small">No successors.</p>';
        return;
      }

      let succArray = successors;
      const filterVal = succFilter.value.trim().toLowerCase();
      succArray = filterActivities(succArray, filterVal);

      // Relationship type
      succArray.forEach(succAct => {
        succAct['Relationship Type'] = parseRelationshipType(succAct, currentAct['Activity ID']);
      });

      const field = sortState.succ.field;
      const asc = sortState.succ.asc;
      const relFFMode = sortState.succ.relFFMode;
      sortActivities(succArray, field, asc, relFFMode);

      const floats = succArray.map(s => parseFloat(s['Total Float']) || 0);
      const minTF = Math.min(...floats);
      const maxTF = Math.max(...floats);

      const table = document.createElement('table');
      table.className = 'table table-sm table-bordered relation-table table-hover';
      table.innerHTML = `
        <thead class="table-light">
          <tr>
            <th data-col="Activity ID">ID</th>
            <th data-col="Activity Name">Name</th>
            <th data-col="Start">Start</th>
            <th data-col="Finish">Finish</th>
            <th data-col="Activity Status">Status</th>
            <th data-col="Primary Constraint">Primary Constraint</th>
            <th data-col="Total Float">Total Float</th>
            <th data-col="Activity Type">Activity Type</th>
            <th data-col="Relationship Type">Rel Type</th>
          </tr>
        </thead>
        <tbody id="succTableBody"></tbody>
      `;
      const tbody = table.querySelector('#succTableBody');

      succArray.forEach(succAct => {
        const row = document.createElement('tr');
        row.className = 'activity-card';
        row.ondblclick = () => {
          selectedActivity = succAct;
          showPredecessors(succAct);
          showSuccessors(succAct);
        };

        const idVal = succAct['Activity ID'] || '—';
        const nameVal = succAct['Activity Name'] || '—';
        const startVal = succAct['Start'] || '—';
        const finishVal = succAct['Finish'] || '—';
        const statusVal = succAct['Activity Status'] || '—';
        const pcVal = succAct['Primary Constraint'] || '—';
        const tfVal = succAct['Total Float'] || '—';
        const typeVal = succAct['Activity Type'] || '—';
        const relTypeVal = succAct['Relationship Type'] || '—';

        const rowClass = getRowClassByType(typeVal);
        if (rowClass) {
          row.classList.add(rowClass);
        }

        row.innerHTML = `
          <td><strong>${idVal}</strong></td>
          <td>${nameVal}</td>
          <td>${startVal}</td>
          <td>${finishVal}</td>
          <td>${statusVal}</td>
          <td>${pcVal}</td>
          <td>${tfVal}</td>
          <td>${typeVal}</td>
          <td>${relTypeVal}</td>
        `;

        // float shading
        const cellTF = row.querySelector('td:nth-child(7)');
        if (cellTF && tfVal !== '—') {
          cellTF.style.backgroundColor = getFloatShading(parseFloat(tfVal), minTF, maxTF);
        }

        tbody.appendChild(row);
      });

      successorList.appendChild(table);

      const headers = table.querySelectorAll('th[data-col]');
      headers.forEach(th => {
        th.addEventListener('click', () => {
          const col = th.getAttribute('data-col');
          if (col === 'Rel FF') {
            // Not used for successors in this snippet
          } else {
            if (sortState.succ.field === col) {
              sortState.succ.asc = !sortState.succ.asc;
            } else {
              sortState.succ.field = col;
              sortState.succ.asc = true;
            }
          }
          showSuccessors(currentAct);
        });
      });
    }

    // -------------------------------------------------------------
    // Pred/Succ Filters
    // -------------------------------------------------------------
    predFilter.addEventListener('input', () => {
      if (selectedActivity) {
        showPredecessors(selectedActivity);
      }
    });
    succFilter.addEventListener('input', () => {
      if (selectedActivity) {
        showSuccessors(selectedActivity);
      }
    });

    // -------------------------------------------------------------
    // About / Dark Mode
    // -------------------------------------------------------------
    aboutBtn.addEventListener('click', () => {
      alert(
        "P6 Offline Viewer\n\n" +
        "1. Upload a CSV schedule.\n" +
        "2. Search for an activity and select it to start or reset a CP.\n" +
        "3. Double-click a predecessor to add it cumulatively. Or remove items from CP.\n" +
        "4. Removing the last item updates the preds/succ automatically.\n" +
        "5. 'Rel FF' is consistent in CP and Predecessors, with 3-mode sorting.\n" +
        "6. Filter or sort columns. LOE/milestones included. Enjoy!"
      );
      addLog('Opened About info.');
    });

    darkModeBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      addLog('Toggled Dark Mode.', 'Light <-> Dark theme switched.');
    });
  </script>
</body>
</html>
