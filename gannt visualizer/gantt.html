<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Character set: Ensures correct text encoding -->
  <meta charset="UTF-8" />
  <!-- Page Title -->
  <title>Gantt Planner</title>
  <!-- Bootstrap 5 CSS -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
  />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap">
  <style>
    /* 
     * We rely on native sizing to prevent clipping at bottom.
     * The last row is a 'filler row' that remains always at bottom.
     */
    html,
    body {
      height: 100%; /* Fill the screen height */
      margin: 0;    /* No default margin */
      padding: 0;   /* No default padding */
      overflow: hidden; /* Hide scrollbars to keep the board clean */
      font-family: 'Montserrat', sans-serif; /* Use Montserrat or fallback */
    }

    /*
     * Sticky navbar at the top with scrolling if content grows too large.
     * Height 200px with auto-overflow for a modern, sleek design.
     * Color scheme => Cushman & Wakefield emphasis, 
     * #1C173E (Port Gore) background, #EA1F27 (Alizarin Crimson) border
     */
    .navbar {
      position: sticky;              /* Stay at top */
      top: 0;                        /* No offset from top */
      z-index: 1000;                 /* Ensure it is above table header */
      background-color: #1C173E !important; /* Port Gore color */
      opacity: 90%;                  /* Slight transparency */
      color: #fff !important;        /* White text */
      padding: 0.25rem 0.5rem;       /* Some top/bottom padding */
      width: 100%;                   /* Full width */
      height: 200px;                 /* Fixed height */
      overflow-y: auto;              /* Scroll if content grows too large */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Shadow below */
      border-bottom: 4px solid #EA1F27; /* Red border at bottom */
    }

    /* 
     * Container inside navbar, we adjust to row to place logo on left,
     * then the rest of the toolbar items on the right side.
     */
    .navbar .container-fluid {
      max-width: 100vw;               /* Use full viewport width */
      padding: 0;                     /* Remove default container spacing */
      margin: 0;                      /* Remove default container margin */
      display: flex;                  /* Use flex layout */
      flex-direction: row;            /* Horizontal (row) flow for logo + columns */
      align-items: flex-start;        /* Align items at start */
    }

    /* 
     * Adjust the placeholder image to be 160px in height 
     * (200px total navbar height minus 20px top/bottom = 160).
     * Also add 10px margin around for a 20px total vertical clearance.
     */
    #placeholderImage {
      max-height: 160px; /* 200 - 20px vertical padding = 160 */
      width: auto;       /* Maintain aspect ratio */
      object-fit: contain; /* Contain within bounding box */
      margin: 10px;        /* 10px margin around to align with specs */
    }

    /* 
     * The toolbar portion after the logo still displayed in a row 
     * but we keep columns for each group. 
     */
    .collapse.navbar-collapse {
      display: flex !important;   /* Force flex */
      flex-wrap: nowrap !important; /* No wrapping */
      gap: 1rem;                  /* Gap between columns */
      width: 100%;                /* Full width for the toolbar columns */
    }

    .navbar-brand {
      color: #fff !important; /* White text for brand */
      font-weight: bold;      /* Bold text */
      font-size: 1.2rem;      /* Slightly larger font */
      margin-right: 1rem;     /* Spacing to next item */
    }

    /* Each toolbar column gets a right border except for the last ones we define. */
    .toolbar-column {
      display: flex;               /* Lay out content inside a column horizontally or vertically as needed. */
      flex-direction: row;         /* Typically row layout for internal groups. */
      gap: 0.5rem;                 /* Gap between groups in the column */
      padding-right: 0.5rem;       /* Right padding */
      align-items: center;         /* Vertically center items */
      border-right: 1px solid #EA1F27; /* Right border in red */
    }
    .toolbar-column:last-child {
      border-right: none;
      padding-right: 0;
    }

    /* Each group in the toolbar can be stacked or row-based. */
    .toolbar-group {
      display: flex;           /* Container for items in a group */
      flex-direction: column;  /* Typically stacked vertically */
      gap: 0.25rem;            /* Small vertical gap */
      color: #fff;             /* White text for labels */
      justify-content: center;
    }
    .toolbar-group label {
      margin-bottom: 0;            /* No extra margin */
      font-weight: 600;            /* Semibold label text */
      color: #fff;                 /* White color */
    }

    /* Timescale row and columns for Start Year/Week inputs. */
    .timescale-row {
      display: flex;           /* Horizontal row */
      flex-direction: row;     /* side by side columns */
      gap: 0.75rem;            /* space between them */
    }
    .timescale-col {
      display: flex;           /* Vertical stacking of label/input sets */
      flex-direction: column;
      gap: 0.25rem;
    }
    .timescale-col label {
      font-size: 0.85rem;      /* Slightly smaller text */
      color: #fff;             /* White text */
    }

    /* Form controls on the navbar => dark background with red border. */
    .navbar input.form-control,
    .navbar select.form-select {
      background-color: #1C173E;  /* Dark background */
      color: #fff;                /* White text */
      border: 1px solid #EA1F27;  /* Red border */
      font-weight: 500;           /* Semi-bold text */
    }
    .navbar input.form-control:focus,
    .navbar select.form-select:focus {
      outline: 1px solid #FFf;    /* White outline on focus */
      box-shadow: 0 0 5px 0 #FFf; /* Glow effect on focus */
    }

    /* Navbar buttons => transparent background, white text, 1px border. */
    .navbar .btn {
      border: 1px solid #FFf;     /* White border */
      color: #FFf;                /* White text */
      font-weight: 600;           /* Bold text */
      padding: 2px 8px;           /* Button padding */
      background: transparent;    /* Transparent bg */
    }
    /* Hover => red background, white text. */
    .navbar .btn:hover {
      background-color: #EA1F27;  /* Red on hover */
      color: #fff;
      border-color: #EA1F27;      /* Match red border */
    }

    /* Gantt container => main area below the navbar. */
    .gantt-container {
      position: relative;           /* Positioned container */
      height: calc(100% - 100px);   /* The lower portion for the table => leftover from the full screen, minus some offset */
      margin-bottom: 0;             /* No bottom margin */
    }

    /* Table wrapper => scrollable area. */
    .table-wrapper {
      position: absolute;  /* Absolutely fill the container */
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: auto;      /* Scrollable content */
      box-sizing: border-box;  /* Border-box sizing */
      padding-bottom: 100px;   /* Extra bottom padding buffer */
    }

    /* The main Gantt table => spans entire width. */
    #ganttTable {
      width: 100%;               /* Full width table */
      border-collapse: collapse; /* Collapse cell borders */
      table-layout: fixed;       /* Fixed table layout => columns have fixed widths */
      position: relative;        /* For stacking bar elements if needed */
    }
    #ganttTable,
    #ganttTable thead th,
    #ganttTable tbody td {
      border: 1px solid #000;    /* Borders for clarity */
    }

    /* Sticky table header at top. */
    #ganttTable thead {
      position: sticky;  /* Stays visible when scrolling vertically */
      top: 0;            /* No offset from top */
      z-index: 50;       /* Above the normal content */
      background: #f8f9fa;  /* Light background */
    }
    #ganttTable thead th {
      background-color: #f8f9fa;  /* Light gray */
      text-align: center;         /* Center text */
      font-size: 0.9rem;          /* Smaller font size */
      padding: 4px 8px;           /* Padding for readability */
      box-sizing: border-box;     /* Inherit box sizing */
      overflow: hidden;           /* Hide long text overflow */
      text-overflow: ellipses;    /* Indicate clipped text */
    }

    /* The "Tasks" column in the header => sticky on the left, separate z-index. */
    #nameHeader {
      width: 300px;               /* Wider for line names */
      text-align: center;         /* Center text */
      font-weight: bold;          /* Bold heading */
      background-color: #f8f9fa;  /* Light gray background */
      z-index: 51;                /* Slightly above normal header cells */
    }

    /* 
     * Date header cells for year, month, week => adding a black border 
     * to emphasize the date headers as requested. 
     */
    .timescale-header {
      background-color: #e9ecef;  /* Subtle color for timescale cells */
      min-width: 50px;            /* Minimum width for smaller screens */
      border: 2px solid #000;     /* black outline for date headers */
    }

    #ganttTable tbody {
      position: relative;  /* For bar overlays if needed */
    }
    /* Each row in the Gantt */
    .gantt-row {
      height: var(--row-height);    /* Use row-height CSS var from JS */
      transition: outline 0.2s;     /* Smooth highlight transition */
    }
    .gantt-row.selected {
      background-color: #fff3cd;    /* Highlight for selected row */
    }
    .gantt-row.drag-highlight {
      outline: 3px solid #EA1F27;   /* Red outline if dragging line */
    }

    .filler-row {
      height: 40px; /* Just a filler, not used in dynamic code */
    }

    /* Left "Name" column cells => sticky for line labels. */
    .name-cell {
      position: sticky;                  /* Sticky left */
      left: 0;                           /* Left edge pinned */
      background-color: #f0f0f0;         /* Light background */
      box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2); /* Slight shadow */
      z-index: 9;                        /* Over bars */
      width: 300px;                      /* Fixed width from heading */
      display: flex;                     /* Flex to center text if needed */
      justify-content: center;           /* Center horizontally */
      align-items: center;               /* Center vertically */
      height: var(--row-height);         /* Match the row height */
      box-sizing: border-box;            /* Include padding in width */
      cursor: move;                      /* Draggable UI cursor */
    }

    /* Name label text => truncated if too long. */
    .name-cell span {
      font-size: 0.85rem;      /* Slightly smaller text */
      white-space: nowrap;     /* Prevent wrap */
      overflow: hidden;        /* Hide overflow */
      text-overflow: ellipses; /* Ellipses effect */
      display: inline-block;   /* Inline-block for text styling */
      max-width: 90%;          /* Prevent overflow beyond cell */
    }

    /* The bar cells => hold Gantt bars. */
    .bar-cell {
      position: relative;  /* Container for bar overlays */
      padding: 0;          /* No default padding for cell */
    }
    .bar-row-container {
      position: relative;  /* For absolutely positioned bars */
      width: 100%;         /* Fill cell horizontally */
      height: 100%;        /* Fill cell vertically */
      display: flex;       /* Possibly align items center */
      align-items: center;
    }

    /* Gantt bars => absolute positioning within row container. */
    .bar {
      position: absolute;       /* Freed from document flow, placed by left & width */
      height: calc(var(--row-height) - 20px); 
      left: 0;                  /* Default left 0, updated in code */
      border-radius: 4px;       /* Rounded corners */
      color: #fff;              /* White text by default */
      cursor: pointer;          /* Indicate clickable/dragable element */
      user-select: none;        /* Prevent text selection while dragging */
      opacity: 0.7;             /* Slight transparency */
      overflow: hidden;         /* Hide text overflow inside bar */
      z-index: 0;               /* Stacking behind the name cell */
      box-sizing: border-box;   /* Border box for sizing */
      border: 2px solid #000;   /* Black border around bar */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Drop shadow for depth */
    }
    .bar.selected {
      outline: none; 
    }
    .bar.highlighted {
      outline: 3px solid #0d6efd; /* Blue outline if highlight from search */
      opacity: 0.9;               /* More opaque */
    }
    .bar.drag-highlight {
      border: 3px solid #EA1F27 !important; /* Red border while dragging */
    }

    /* 
     * The text inside the bar => absolute, centered vertically at 50% 
     * transform Y by -50%. 
     */
    .bar-text {
      position: absolute;          /* Freed from normal layout */
      top: 50%;                    /* Halfway down the bar */
      transform: translateY(-50%); /* Shift up by half the text height */
      white-space: nowrap;         /* No wrapping */
      pointer-events: none;        /* Click-thru text so bar events still occur */
      font-weight: 500;           /* Semi-bold text */
      padding: 0 4px;             /* Minimal horizontal padding for clarity */
    }

    /* Resize handles => appear on bar edges in admin mode. */
    .bar-handle {
      position: absolute;             /* Freed from normal layout */
      top: 0;                         /* Full height from top:0 to height:100% */
      width: 6px;                     /* Handle width */
      height: 100%;                   /* Full bar height */
      cursor: col-resize;             /* Column resizing pointer */
      background-color: rgba(255, 255, 255, 0.4); /* Translucent white handle */
      z-index: 2;                     /* Above bar for easy grabbing */
    }
    .bar-handle.left {
      left: 0;                        /* Left edge handle */
      border-radius: 4px 0 0 4px;     /* Round left corners */
    }
    .bar-handle.right {
      right: 0;                       /* Right edge handle */
      border-radius: 0 4px 4px 0;     /* Round right corners */
    }

    /* Overlap hatch => diagonal stripes if bars overlap. */
    .overlap-hatch {
      position: absolute;  /* Freed from normal layout */
      height: calc(var(--row-height) - 16px); 
      background: repeating-linear-gradient(
        45deg,
        #EA1F27,
        #EA1F27 2px,
        transparent 2px,
        transparent 4px
      );
      opacity: 0.5;           /* Slight transparency */
      pointer-events: none;   /* No interaction, just visual */
      z-index: 1;             /* Above bars but below handles? */
    }

    /* Pop-up editor for bar => absolute hidden by default. */
    #barEditor,
    #lineEditor {
      position: absolute;       /* Freed from normal layout, placed by JS */
      display: none;            /* Hidden initially */
      background: #fff;         /* White background box */
      border: 1px solid #ccc;   /* Border for clarity */
      padding: 8px;             /* Inside spacing */
      border-radius: 6px;       /* Rounded corners */
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5); /* Shadow for depth */
      z-index: 9999;            /* Above everything */
      max-height: 80vh;         /* Limit maximum height */
      overflow: auto;           /* Scroll if content is long */
      max-width: 90vw;          /* Limit max width on small screens */
    }
    #barEditor {
      min-width: 200px;  /* Enough width for bar inputs */
    }
    #lineEditor {
      min-width: 280px;  /* Enough width for line inputs */
    }
    /* Editor attribute row => label + input side by side. */
    .attribute-row {
      display: flex;              /* Horizontal layout */
      align-items: center;        /* Center vertically */
      margin-bottom: 6px;         /* Spacing between fields */
    }
    .attribute-row label {
      flex: 0 0 auto;             /* Label doesn't stretch */
      margin-right: 6px;          /* Space between label & input */
      font-weight: 500;           /* Semi-bold label */
    }
    .attribute-row input,
    .attribute-row select {
      flex: 1 1 auto;            /* Grow to fill remaining width */
    }
    /* Actions => "OK", "Cancel" etc, aligned to the right. */
    #barEditorActions,
    #lineEditorActions {
      display: flex;              /* Horizontal row of buttons */
      justify-content: flex-end;  /* Right alignment */
      gap: 8px;                   /* Spacing between buttons */
      margin-top: 12px;           /* Some top margin */
    }

    /* Filter modal => also hidden initially. */
    #filterModal {
      display: none;
      position: fixed;               /* Fixed in viewport */
      top: 50%;                      /* Center vertically */
      left: 50%;                     /* Center horizontally */
      transform: translate(-50%, -50%); /* Actually center via transform */
      background: #fff;              /* White background */
      border: 1px solid #ccc;        /* Light gray border */
      padding: 10px;                 /* Some padding */
      border-radius: 6px;            /* Rounded corners */
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5); /* Drop shadow */
      z-index: 9999;                 /* Above other UI */
      min-width: 400px;             /* Reasonable minimum width */
      max-height: 90vh;             /* Limit height if small screen */
      overflow: auto;               /* Scroll content if needed */
      font-size: 0.85rem;           /* Slightly smaller text in filter */
    }
    #filterModal h3 {
      margin-top: 0;    /* No top margin */
      font-size: 1rem;  /* 1rem heading */
    }
    .filter-container {
      display: flex;                /* Horizontal layout for two cards */
      flex-direction: row;
      justify-content: space-between; /* Spread them out */
      gap: 20px;                    /* Gap between filter cards */
    }
    .filter-card {
      background: #f8f9fa;     /* Light gray background */
      padding: 10px;           /* Spacing inside card */
      border-radius: 6px;      /* Rounded corners */
      flex: 1;                 /* Each card grows equally */
      display: flex;           /* Stack vertical filter fields */
      flex-direction: column;
      gap: 6px;                /* Space between fields */
    }
    .filter-card h5 {
      margin-top: 0;           /* Tight top */
      margin-bottom: 6px;      /* Slight gap to next item */
      font-size: 0.95rem; 
      font-weight: 600;        /* Semibold card title */
    }
    /* Filter action buttons => aligned on right. */
    #filterActions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 12px;
    }

    /* Settings modal => for theme settings. Hidden initially. */
    #settingsModal {
      display: none;
      position: fixed;               /* Fixed in viewport center */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;              /* White background box */
      border: 1px solid #ccc;        /* Border for clarity */
      padding: 20px;                 /* Internal spacing */
      border-radius: 6px;            /* Rounded corners */
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5); /* Shadow for depth */
      z-index: 9999;                 /* Above main UI */
      min-width: 300px;             /* Minimum width */
      max-height: 80vh;             /* Limit height on small screens */
      max-width: 90vw;              /* Let it shrink on small screens */
      overflow: auto;               /* Scroll if content is tall */
    }
    #settingsModal h3 {
      margin-top: 0;  /* No top margin */
    }
    #settingsModal label {
      display: block;
      margin-top: 8px;    /* Gap for each setting row */
    }
    #settingsActions {
      display: flex;
      justify-content: flex-end; /* Right align */
      gap: 8px;                  /* Spacing between buttons */
      margin-top: 12px;          /* Some top margin */
    }
    /* Color-picker input => small box for color preview. */
    .color-picker {
      width: 60px;
      height: 30px;
      padding: 0;
      border: none;
      cursor: pointer;
    }

    /* CSV Edit modal => large text area for CSV. Hidden initially. */
    #csvEditModal {
      display: none;
      position: fixed;  /* Center in viewport */
      top: 50%;
      left: 50%;
      width: 60%;       /* Occupy 60% of viewport width */
      height: 60%;      /* 60% of viewport height */
      transform: translate(-50%, -50%);
      background: #fff; /* White background */
      border: 1px solid #ccc;  /* Gray border */
      padding: 10px;           /* Internal spacing */
      border-radius: 6px;      /* Rounded corners */
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5); /* Drop shadow */
      z-index: 99999;          /* Highest index so it doesn't get hidden */
      overflow: auto;          /* Scroll if content is tall */
    }
    #csvTextarea {
      width: 100%;        /* Full width in container */
      height: 70%;        /* Large portion of vertical space */
      font-family: 'Montserrat'; /* Same font family for consistency */
      font-size: 0.9rem;  /* Slightly larger text for easier editing */
    }
    #csvEditModalActions {
      margin-top: 10px;            /* Space above buttons */
      display: flex;               /* Horizontal row of buttons */
      justify-content: flex-end;   /* Align to the right */
      gap: 8px;                    /* Spacing between action buttons */
    }

    /* Dark theme => override background, text, etc. */
    body.dark-theme {
      background-color: #212529;
      color: #fff;
    }
    body.dark-theme .navbar {
      background-color: #1C173E !important;
      color: #FFf !important;
      border-bottom: 4px solid #EA1F27;
    }
    body.dark-theme #ganttTable thead th,
    body.dark-theme .timescale-header {
      background-color: #495057; /* Darker table header background */
      color: #fff;
    }
    body.dark-theme .name-cell {
      background-color: #444;
      color: #fff;
      box-shadow: 1px 1px 3px rgba(255, 255, 255, 0.2);
    }
    body.dark-theme .bar-text {
      color: #fff;
    }
    body.dark-theme #barEditor,
    body.dark-theme #lineEditor,
    body.dark-theme #filterModal,
    body.dark-theme #settingsModal,
    body.dark-theme #csvEditModal {
      background: #343a40;
      color: #fff;
      border: 1px solid #495057;
    }
    body.dark-theme input,
    body.dark-theme select,
    body.dark-theme textarea {
      background: #495057;
      color: #fff;
      border: 1px solid #6c757d;
    }
    body.dark-theme .bar {
      border: 2px solid #fff;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    }

    /* Zoom slider => styled for horizontal track, custom thumb. */
    .zoom-slider {
      width: 120px;                /* 120px wide by default */
      margin: 0 8px;               /* Some horizontal margin */
      height: 8px;                 /* Thinner track height */
      border-radius: 4px;          /* Rounded track corners */
      background: #ced4da;         /* Light gray track */
      outline: none;               /* No outline on focus */
      -webkit-appearance: none;    /* Remove default custom styling in Chrome/Safari */
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25); /* Subtle shadow on track */
    }
    .zoom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;    /* Remove default styling */
      width: 20px;                 /* Thumb width */
      height: 20px;                /* Thumb height */
      border-radius: 50%;          /* Circular thumb */
      background: #EA1F27;         /* Red color */
      cursor: pointer;             /* Indicate draggable */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); /* Subtle shadow */
    }
    .zoom-slider::-moz-range-thumb {
      width: 20px;                 /* Similar for Firefox */
      height: 20px;
      border-radius: 50%;
      background: #EA1F27;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    /* Height zoom custom slider. */
    #heightZoomSlider {
      width: 120px; /* Same sizing for vertical row */
    }

    @media print {
      .navbar,
      #barEditor,
      #lineEditor,
      #filterModal,
      #settingsModal,
      #csvEditModal {
        display: none !important;
      }
    }

    /* Legend items => stacked vertically by default. */
    .legend-container-vertical {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .legend-item {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 4px;
    }
    .legend-swatch {
      width: 16px;
      height: 16px;
    }

    /* Slicers horizontally => each group stacked in small columns. */
    .slicers-horizontal {
      display: flex;
      padding:10px;
      flex-direction: row;
      gap: 1rem;
      align-items: flex-end;
      overflow-y: auto;
      font-size: 4px;
      box-sizing: border-box;
    }
    .slicer-group label {
      white-space: nowrap;
      overflow: visible;
      text-overflow: clip;
      color: #fff;
      font-weight: 600;
    }
    .slicer-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      align-items: flex-start;
      font-size:15px;
    }
    .slicer-group button {
      width: 60px;
      align-self: flex-start;
      font-size:10px;
    }

    /* Hide addItemsGroup by default => toggled by admin mode. */
    #addItemsGroup {
      display: none; 
    }
  </style>
</head>
<body>
  <!-- Sticky navbar with arranged columns -->
  <nav class="navbar navbar-expand-lg">
    <div class="container-fluid">
      <!-- The image placeholder on far left. -->
      <img 
        id="placeholderImage" 
        src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR9aY5rychRdaXi0JWOlqHrbP0LWvlPWn7L_g&s?raw=true" 
        alt="Placeholder Logo" 
      />

      <!-- The lower portion with the toolbar columns (flex row with columns). -->
      <div
        class="collapse navbar-collapse"
        id="navbarSupportedContent"
        style="display: flex; flex-direction: row; gap: 1rem; width:100%;"
      >
        <!-- Column 1 => Timescale -->
        <div class="toolbar-column">
          <div class="toolbar-group">
            <span style="font-weight:700;">Timescale</span>
            <div class="timescale-row">
              <div class="timescale-col">
                <label for="startYearInput" class="form-label">Start Year:</label>
                <input
                  id="startYearInput"
                  type="number"
                  class="form-control form-control-sm"
                  value="2025"
                />
                <label for="startWeekInput" class="form-label">Start Week:</label>
                <input
                  id="startWeekInput"
                  type="number"
                  class="form-control form-control-sm"
                  value="1"
                />
              </div>
            </div>
          </div>
        </div>

        <!-- Column 2 => Zoom & Search -->
        <div class="toolbar-column">
          <div class="toolbar-group">
            <span style="font-weight:700;">Zoom</span>
            <!-- Stack the two slider sections vertically, with minimal gap -->
            <div style="display: flex; flex-direction: column; gap: 0.25rem;">
              <div style="display:flex; flex-direction: row; align-items: center; gap: 0.25rem;">
                <label for="zoomSlider" class="form-label m-0 me-2">H-Zoom:</label>
                <input
                  type="range"
                  class="zoom-slider"
                  id="zoomSlider"
                  min="10"
                  max="300"
                  value="150"
                  step="10"
                />
              </div>
              <div style="display:flex; flex-direction: row; align-items: center; gap: 0.25rem;">
                <label for="heightZoomSlider" class="form-label m-0 me-2">V-Zoom:</label>
                <input
                  type="range"
                  class="zoom-slider"
                  id="heightZoomSlider"
                  min="30"
                  max="100"
                  value="40"
                  step="5"
                />
              </div>
            </div>
          </div>
          <div class="toolbar-group">
            <span style="font-weight:700;">Search</span>
            <input
              type="text"
              id="searchInput"
              class="form-control form-control-sm"
              placeholder="Filter lines/bars..."
            />
            <button id="filterBtn" class="btn btn-sm mt-1">
              Filter
            </button>
          </div>
        </div>

        <!-- Column 3 => Add Items & History -->
        <div class="toolbar-column">
          <div id="addItemsGroup" class="toolbar-group">
            <span style="font-weight:700;">Add Items</span>
            <button id="addLineItemBtn" class="btn btn-sm">
              Add Line
            </button>
            <button id="addBarBtn" class="btn btn-sm">
              Add Bar
            </button>
          </div>
          <div class="toolbar-group">
            <span style="font-weight:700;">History</span>
            <button id="undoBtn" type="button" class="btn btn-sm">
              Undo
            </button>
            <button id="redoBtn" class="btn btn-sm">
              Redo
            </button>
          </div>
        </div>

        <!-- Column 4 => Legend -->
        <div class="toolbar-column">
          <div class="toolbar-group legend-container-vertical" id="legendContainer">
            <div class="legend-item">
              <div class="legend-swatch" id="legendSecuredSwatch"></div>
              <span>Secured</span>
            </div>
            <div class="legend-item">
              <div class="legend-swatch" id="legendProposedSwatch"></div>
              <span>Proposed</span>
            </div>
            <div class="legend-item">
              <div class="legend-swatch" id="legendOpportunitySwatch"></div>
              <span>Opportunity</span>
            </div>
            <div class="legend-item">
              <div class="legend-swatch" id="legendFutureSwatch"></div>
              <span>Future</span>
            </div>
          </div>
        </div>

        <!-- Column 5 => Import/Export/Print -->
        <div class="toolbar-column">
          <div class="toolbar-group">
            <span style="font-weight:700;">Import/Export</span>
            <button id="importCsvBtn" class="btn btn-sm">
              Import CSV
            </button>
            <button id="downloadCsvBtn" class="btn btn-sm">
              Export CSV
            </button>
            <button id="printBtn" class="btn btn-sm">
              Print/PDF
            </button>
          </div>
        </div>

        <!-- Column 6 => Misc => Admin & Theme/About toggles -->
        <div class="toolbar-column">
          <div class="toolbar-group">
            <span style="font-weight:700;">Misc</span>
            <button id="adminToggleBtn" class="btn btn-sm">
              Admin
            </button>
            <button id="themeToggleBtn" class="btn btn-sm">
              Theme
            </button>
            <button id="aboutToggleBtn" class="btn btn-sm">
              About
            </button>
            <button
              id="csvEditToggleBtn"
              class="btn btn-sm"
              style="display: none;"
            >
              Edit CSV
            </button>
          </div>
        </div>

        <!-- Column 7 => Slicers -->
        <div class="toolbar-column">
          <div class="slicers-horizontal">
            <div class="slicer-group">
              <label>Discipline</label>
              <button
                id="clearDisciplineSlicerBtn"
                class="btn btn-sm"
              >
                Clear
              </button>
              <select
                id="slicerDisciplineSelect"
                class="form-select form-select-sm"
                multiple
              ></select>
            </div>
            <div class="slicer-group">
              <label>Client</label>
              <button id="clearClientSlicerBtn" class="btn btn-sm">
                Clear
              </button>
              <select
                id="slicerClientSelect"
                class="form-select form-select-sm"
                multiple
              ></select>
            </div>
            <div class="slicer-group">
              <label>Experience</label>
              <button
                id="clearExperienceSlicerBtn"
                class="btn btn-sm"
              >
                Clear
              </button>
              <select
                id="slicerExperienceSelect"
                class="form-select form-select-sm"
                multiple
              ></select>
            </div>
            <div class="slicer-group">
              <label>Location</label>
              <button
                id="clearLocationSlicerBtn"
                class="btn btn-sm"
              >
                Clear
              </button>
              <select
                id="slicerLocationSelect"
                class="form-select form-select-sm"
                multiple
              ></select>
            </div>
          </div>
        </div>

        <!-- Column 8 => Sorting (UPDATED) -->
        <div class="toolbar-column">
          <div class="toolbar-group">
            <!-- Main label for sorting -->
            <span style="font-weight:700;">Sort</span>
            
            <!-- Primary Sort Field + Direction -->
            <label style="font-size:0.8rem; margin-top:4px;">Primary Field:</label>
            <select id="sortFieldSelect" class="form-select form-select-sm">
              <option value="">None</option>
              <option value="label">Label</option>
              <option value="projectName">Project Name</option>
              <option value="client">Client</option>
              <option value="discipline">Discipline</option>
              <option value="experience">Experience</option>
              <option value="location">Location</option>
              <option value="assignedTo">Assigned To</option>
              <option value="startAbsWeek">Start (Absolute)</option>
              <!-- ADDED finishAbsWeek to sort by bar's end date -->
              <option value="finishAbsWeek">Finish (Absolute)</option>
              <option value="length">Duration</option>
              <option value="LOE">LOE</option>
              <!-- New lineType option to sort by line's 'type' attribute -->
              <option value="lineType">Line Type</option>
            </select>

            <label style="font-size:0.8rem; margin-top:4px;">Primary Direction:</label>
            <select id="sortDirectionSelect" class="form-select form-select-sm">
              <option value="asc">Ascending</option>
              <option value="desc">Descending</option>
            </select>

            <!-- Secondary Sort Field + Direction -->
            <label style="font-size:0.8rem; margin-top:4px;">Secondary Field:</label>
            <select id="sortFieldSelect2" class="form-select form-select-sm">
              <option value="">None</option>
              <option value="label">Label</option>
              <option value="projectName">Project Name</option>
              <option value="client">Client</option>
              <option value="discipline">Discipline</option>
              <option value="experience">Experience</option>
              <option value="location">Location</option>
              <option value="assignedTo">Assigned To</option>
              <option value="startAbsWeek">Start (Absolute)</option>
              <!-- ADDED finishAbsWeek to sort by bar's end date -->
              <option value="finishAbsWeek">Finish (Absolute)</option>
              <option value="length">Duration</option>
              <option value="LOE">LOE</option>
              <!-- Again lineType for secondary sorting -->
              <option value="lineType">Line Type</option>
            </select>

            <label style="font-size:0.8rem; margin-top:4px;">Secondary Direction:</label>
            <select id="sortDirectionSelect2" class="form-select form-select-sm">
              <option value="asc">Ascending</option>
              <option value="desc">Descending</option>
            </select>
            
            <!-- The "Apply Sort" button was removed, so no button here -->
          </div>
        </div>
        <!-- End of columns -->
      </div>
    </div>
  </nav>

  <!-- Gantt container => table wrapper -->
  <div class="gantt-container">
    <div class="table-wrapper" id="tableWrapper">
      <table id="ganttTable">
        <thead>
          <!-- Timescale built dynamically -->
        </thead>
        <tbody id="tableBody">
          <!-- Rows generated dynamically -->
        </tbody>
      </table>
    </div>
  </div>

  <!-- Bar editor => single label plus attributes -->
  <div id="barEditor">
    <div class="attribute-row">
      <label for="barLabelInput">Bar Label:</label>
      <input type="text" id="barLabelInput" placeholder="Bar Label..." />
    </div>
    <div class="attribute-row">
      <label for="barProjectNameInput">Project Name:</label>
      <input type="text" id="barProjectNameInput" placeholder="Project Name..." />
    </div>
    <div class="attribute-row">
      <label for="barClientInput">Client:</label>
      <input type="text" id="barClientInput" placeholder="Client..." />
    </div>
    <div class="attribute-row">
      <label for="barDisciplineInput">Discipline:</label>
      <input type="text" id="barDisciplineInput" placeholder="Discipline..." />
    </div>
    <div class="attribute-row">
      <label for="barExperienceInput">Experience:</label>
      <input type="text" id="barExperienceInput" placeholder="Experience..." />
    </div>
    <div class="attribute-row">
      <label for="barLOEInput">LOE:</label>
      <input type="text" id="barLOEInput" placeholder="LOE..." />
    </div>
    <div class="attribute-row">
      <label for="barLocationInput">Location:</label>
      <input type="text" id="barLocationInput" placeholder="Location..." />
    </div>
    <div class="attribute-row">
      <label for="barAssignedToInput">Assigned to:</label>
      <input type="text" id="barAssignedToInput" placeholder="Assigned to..." />
    </div>
    <div class="attribute-row">
      <label for="barTypeSelect">Type (affects color):</label>
      <select id="barTypeSelect">
        <option value="secured">Secured</option>
        <option value="proposed">Proposed</option>
        <option value="opportunity">Opportunity</option>
        <option value="future">Future</option>
      </select>
    </div>
    <div class="attribute-row">
      <label for="barProposedSelect">Proposed:</label>
      <select id="barProposedSelect">
        <option value="yes">Yes</option>
        <option value="no">No</option>
      </select>
    </div>
    <div class="attribute-row">
      <label for="startYearSelect">Start (Y/W):</label>
      <select id="startYearSelect"></select>
      <select id="startWeekSelect"></select>
    </div>
    <div class="attribute-row">
      <label for="endYearSelect">End (Y/W):</label>
      <select id="endYearSelect"></select>
      <select id="endWeekSelect"></select>
    </div>
    <div id="barEditorActions">
      <button id="barDeleteBtn" class="btn btn-sm">Delete Bar</button>
      <button id="barEditorOkBtn" class="btn btn-sm">OK</button>
      <button id="barEditorCancelBtn" class="btn btn-sm">
        Cancel
      </button>
    </div>
  </div>

  <!-- Line editor -->
  <div id="lineEditor">
    <div class="attribute-row">
      <label for="lineNameInput">Name:</label>
      <input type="text" id="lineNameInput" placeholder="Name..." />
    </div>
    <div class="attribute-row">
      <label for="lineClientInput">Client:</label>
      <input type="text" id="lineClientInput" placeholder="Client..." />
    </div>
    <div class="attribute-row">
      <label for="lineDisciplineInput">Discipline:</label>
      <input type="text" id="lineDisciplineInput" placeholder="Discipline..." />
    </div>
    <div class="attribute-row">
      <label for="lineExperienceInput">Experience:</label>
      <input type="text" id="lineExperienceInput" placeholder="Experience..." />
    </div>
    <div class="attribute-row">
      <label for="lineOfficeLocationInput">Office Location:</label>
      <input
        type="text"
        id="lineOfficeLocationInput"
        placeholder="Office Location..."
      />
    </div>
    <div class="attribute-row">
      <label for="lineGeoLocationInput">Geo Location:</label>
      <input
        type="text"
        id="lineGeoLocationInput"
        placeholder="Geo Location..."
      />
    </div>
    <div class="attribute-row">
      <label for="lineTypeInput">Type:</label>
      <input type="text" id="lineTypeInput" placeholder="Type..." />
    </div>
    <div id="lineEditorActions">
      <button id="lineDeleteBtn" class="btn btn-sm">
        Delete Line Item
      </button>
      <button id="lineEditorOkBtn" class="btn btn-sm">OK</button>
      <button id="lineEditorCancelBtn" class="btn btn-sm">
        Cancel
      </button>
    </div>
  </div>

  <!-- Filter modal -->
  <div id="filterModal">
    <h3>Filter Lines/Bars</h3>
    <div class="filter-container">
      <!-- Left filter card => line item fields -->
      <div class="filter-card">
        <h5>Line Item Filters</h5>
        <label for="filterLineName">Name:</label>
        <select id="filterLineName" class="form-select form-select-sm"></select>

        <label for="filterLineClient">Client:</label>
        <select id="filterLineClient" class="form-select form-select-sm"></select>

        <label for="filterLineDiscipline">Discipline:</label>
        <select
          id="filterLineDiscipline"
          class="form-select form-select-sm"
        ></select>

        <label for="filterLineExperience">Experience:</label>
        <select
          id="filterLineExperience"
          class="form-select form-select-sm"
        ></select>

        <label for="filterLineOfficeLocation">Office Location:</label>
        <select
          id="filterLineOfficeLocation"
          class="form-select form-select-sm"
        ></select>

        <label for="filterLineGeoLocation">Geo Location:</label>
        <select
          id="filterLineGeoLocation"
          class="form-select form-select-sm"
        ></select>

        <label for="filterLineType">Type:</label>
        <select id="filterLineType" class="form-select form-select-sm"></select>
      </div>
      <!-- Right filter card => bar attributes -->
      <div class="filter-card">
        <h5>Bar Filters</h5>
        <label for="filterBarProjectName">Project Name:</label>
        <select id="filterBarProjectName" class="form-select form-select-sm"></select>

        <label for="filterBarClient">Client:</label>
        <select id="filterBarClient" class="form-select form-select-sm"></select>

        <label for="filterBarDiscipline">Discipline:</label>
        <select
          id="filterBarDiscipline"
          class="form-select form-select-sm"
        ></select>

        <label for="filterBarExperience">Experience:</label>
        <select
          id="filterBarExperience"
          class="form-select form-select-sm"
        ></select>

        <label for="filterBarLOE">LOE:</label>
        <select id="filterBarLOE" class="form-select form-select-sm"></select>

        <label for="filterBarLocation">Location:</label>
        <select id="filterBarLocation" class="form-select form-select-sm"></select>

        <label for="filterBarAssignedTo">Assigned to:</label>
        <select
          id="filterBarAssignedTo"
          class="form-select form-select-sm"
        ></select>

        <label for="filterBarType">Type:</label>
        <select id="filterBarType" class="form-select form-select-sm"></select>

        <label for="filterBarProposed">Proposed:</label>
        <select
          id="filterBarProposed"
          class="form-select form-select-sm"
        ></select>
      </div>
    </div>
    <div id="filterActions">
      <button id="filterApplyBtn" class="btn btn-sm">Apply</button>
      <button id="filterClearBtn" class="btn btn-sm">
        Clear
      </button>
      <button id="filterCancelBtn" class="btn btn-sm">
        Cancel
      </button>
    </div>
  </div>

  <!-- Settings modal -->
  <div id="settingsModal">
    <h3>Theme Settings</h3>
    <label>Theme:</label>
    <select id="themeSelect">
      <option value="light">Light</option>
      <option value="dark">Dark</option>
    </select>

    <label for="securedColor">Secured Color:</label>
    <input
      type="color"
      id="securedColor"
      class="color-picker"
      value="#28a745"
    />

    <label for="proposedColor">Proposed Color:</label>
    <input
      type="color"
      id="proposedColor"
      class="color-picker"
      value="#fd7e14"
    />

    <label for="opportunityColor">Opportunity Color:</label>
    <input
      type="color"
      id="opportunityColor"
      class="color-picker"
      value="#dc3545"
    />

    <label for="futureColor">Future Color:</label>
    <input
      type="color"
      id="futureColor"
      class="color-picker"
      value="#6f42c1"
    />

    <div id="settingsActions">
      <button id="settingsOkBtn" class="btn btn-sm">Apply</button>
      <button id="settingsCancelBtn" class="btn btn-sm">
        Cancel
      </button>
    </div>
  </div>

  <!-- CSV Edit modal -->
  <div id="csvEditModal">
    <h3>Edit CSV In-Browser</h3>
    <textarea id="csvTextarea"></textarea>
    <div id="csvEditModalActions">
      <button id="csvEditApplyBtn" class="btn btn-sm">
        Apply Changes
      </button>
      <button id="csvEditCancelBtn" class="btn btn-sm">
        Close
      </button>
    </div>
  </div>

  <!-- Hidden file input for CSV import only -->
  <input type="file" id="importFileInput" accept=".csv" style="display: none;" />

  <!-- Bootstrap 5 JS bundle -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    /* 
      ---------------------------------------------------------------------------------------------
      GLOBALS 
      ---------------------------------------------------------------------------------------------
      These variables store the overall state of the Gantt chart and user configurations.
    */
    let adminMode = false;  // Tracks if user is in admin mode or not
    // Default type colors for bars
    let typeColors = {
      secured: "#28a745",
      proposed: "#fd7e14",
      opportunity: "#dc3545",
      future: "#6f42c1",
    };

    // Example data => lines array with nested bars
    let lines = [
      {
        id: 1,
        name: "Line One",
        client: "",
        discipline: "",
        experience: "",
        officeLocation: "",
        geoLocation: "",
        type: "",
        bars: [
          {
            id: 101,
            label: "Bar Sample A",
            projectName: "Proj A",
            client: "",
            discipline: "",
            experience: "",
            LOE: "",
            location: "",
            assignedTo: "",
            proposed: "no",
            type: "secured",
            startAbsWeek: toAbsoluteWeek(2025, 2),
            length: 4,
            selected: false,
            dragging: false,
          },
        ],
        selected: false,
        dragging: false,
      },
      {
        id: 2,
        name: "Line Two",
        client: "",
        discipline: "",
        experience: "",
        officeLocation: "",
        geoLocation: "",
        type: "",
        bars: [
          {
            id: 102,
            label: "Bar Sample B",
            projectName: "Proj B",
            client: "",
            discipline: "",
            experience: "",
            LOE: "",
            location: "",
            assignedTo: "",
            proposed: "yes",
            type: "proposed",
            startAbsWeek: toAbsoluteWeek(2025, 10),
            length: 7,
            selected: false,
            dragging: false,
          },
        ],
        selected: false,
        dragging: false,
      },
    ];

    // Timescale logic => always 10 years from start.
    let startYear = 2025; // Start year
    let startWeek = 1;    // Start week
    let endYear = 2035;   // End year => startYear + 10
    let endWeek = 52;     // Always set to 52

    let lineCounter = 2;  // Track the number of lines
    let barCounter = 102; // Track the number of bars

    let cellWidth = 150;  // Horizontal cell width for 1 week
    let rowHeight = 40;   // Row height for each line

    let filters = { line: {}, bar: {} }; // Filters for lines & bars
    let slicers = { discipline: null, client: null, experience: null, location: null }; // Slicers for multiple select
    let searchTerm = "";           // Text-based search
    let currentTheme = "light";    // Theme: "light" or "dark"

    // Undo/Redo stacks
    let undoStack = [];  // Keep track of past states
    let redoStack = [];  // Keep track of undone states, so we can redo

    // Variables for drag operations
    let dragging = false;           // Flag if user is currently dragging
    let dragType = null;           // Track what type of drag: line reorder, bar move, bar resize
    let dragStartX = 0;            // X coordinate when drag began
    let dragStartY = 0;            // Y coordinate when drag began
    let initialStartAbs = 0;       // Initially recorded bar start (absolute week)
    let initialLength = 0;         // Initially recorded bar length
    let currentBar = null;         // Currently dragged bar
    let currentLine = null;        // Parent line of currently dragged bar
    let draggingLine = null;       // The line currently being dragged if reorder
    let tableBodyRect = null;      // Cached bounding rect of the table body
    let mainFilteredLines = [];    // The lines after filter & search
    let currentEditorBar = null;   // Bar being edited in pop-up
    let currentEditorLine = null;  // Line being edited in pop-up

    /*
      ---------------------------------------------------------------------------------------------
      ADDED: Sorting variables for bars WITH second-level sorting
      ---------------------------------------------------------------------------------------------
    */
    // Main (primary) sort:
    let barSortField = "";         // Which field is used for sorting
    let barSortDirection = "asc";  // 'asc' or 'desc'
    // Secondary sort:
    let barSortField2 = "";        // Second field for stacked sorting
    let barSortDirection2 = "asc"; // 'asc' or 'desc'

    /*
      ---------------------------------------------------------------------------------------------
      Helper functions: time, localStorage, etc.
      ---------------------------------------------------------------------------------------------
    */
    // Convert (year,week) to an absolute integer
    function toAbsoluteWeek(year, week) {
      return year * 52 + (week - 1);
    }
    // Convert absolute integer to (year,week)
    function fromAbsoluteWeek(abs) {
      const y = Math.floor(abs / 52);
      const w = (abs % 52) + 1;
      return { year: y, week: w };
    }
    // Generate month index from year/week => used for timescale labeling
    function getMonthFromYearWeek(year, week) {
      let january4 = new Date(year, 0, 4);
      let dayMs = 24 * 3600 * 1000;
      let offsetDays = (week - 1) * 7 - ((january4.getDay() + 6) % 7);
      let date = new Date(january4.getTime() + offsetDays * dayMs);
      return date.getMonth(); // returns 0-11
    }
    // Return string month name from index 0=Jan
    function getMonthName(m) {
      const months = [
        "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec",
      ];
      return months[m] || "";
    }
    // Get color from bar type
    function getColorFromType(t) {
      return typeColors[t] || "#fd7e14";
    }

    /*
      ---------------------------------------------------------------------------------------------
      Local Storage => save/load chartData
      ---------------------------------------------------------------------------------------------
    */
    // Save everything to localStorage
    function saveToLocalStorage() {
      const chartData = {
        lines,
        startYear,
        startWeek,
        endYear,
        endWeek,
        lineCounter,
        barCounter,
        cellWidth,
        rowHeight,
        typeColors,
        currentTheme,
      };
      localStorage.setItem("ganttChartData", JSON.stringify(chartData));
    }
    // Load from localStorage
    function loadFromLocalStorage() {
      const stored = localStorage.getItem("ganttChartData");
      if (!stored) return; // If no saved data, do nothing
      try {
        let parsed = JSON.parse(stored);
        lines = parsed.lines || [];
        // Clean up lines & bars
        lines.forEach((line) => {
          line.selected = false;
          line.dragging = false;
          line.bars.forEach((bar) => {
            bar.selected = false;
            if (bar.type === undefined) bar.type = "proposed";
            if (bar.label === undefined) bar.label = "";
            if (bar.assignedTo === undefined) bar.assignedTo = "";
            if (bar.dragging === undefined) bar.dragging = false;
          });
          if (!line.client) line.client = "";
        });
        startYear = parsed.startYear || 2025;
        startWeek = parsed.startWeek || 1;
        endYear = (startYear + 10) || 2035;
        endWeek = 52;
        lineCounter = parsed.lineCounter || lineCounter;
        barCounter = parsed.barCounter || barCounter;
        cellWidth = parsed.cellWidth || 150;
        rowHeight = parsed.rowHeight || 40;
        typeColors = parsed.typeColors || typeColors;
        currentTheme = parsed.currentTheme || "light";
      } catch (err) {
        console.warn("Invalid localStorage data");
      }
    }

    /*
      ---------------------------------------------------------------------------------------------
      Theme & CSS
      ---------------------------------------------------------------------------------------------
    */
    // Update legend swatches to reflect color changes
    function updateLegendSwatches() {
      document.getElementById("legendSecuredSwatch").style.backgroundColor = typeColors.secured;
      document.getElementById("legendProposedSwatch").style.backgroundColor = typeColors.proposed;
      document.getElementById("legendOpportunitySwatch").style.backgroundColor = typeColors.opportunity;
      document.getElementById("legendFutureSwatch").style.backgroundColor = typeColors.future;
    }
    // Apply current theme => toggling dark-theme class
    function applyTheme() {
      if (currentTheme === "dark") {
        document.body.classList.add("dark-theme");
      } else {
        document.body.classList.remove("dark-theme");
      }
      updateLegendSwatches();
      renderTable();
      saveToLocalStorage();
    }
    // Update CSS variables for rowHeight, cellWidth
    function updateCSSVariables() {
      document.documentElement.style.setProperty("--cell-width", cellWidth + "px");
      document.documentElement.style.setProperty("--row-height", rowHeight + "px");
    }

    /*
      ---------------------------------------------------------------------------------------------
      getDisplayRange => returns the absolute start & end based on timescale
      ---------------------------------------------------------------------------------------------
    */
    function getDisplayRange() {
      let ds = toAbsoluteWeek(startYear, startWeek);
      let de = toAbsoluteWeek(endYear, endWeek);
      return { displayStart: ds, displayEnd: de };
    }

    /*
      ---------------------------------------------------------------------------------------------
      Misc selection & highlighting
      ---------------------------------------------------------------------------------------------
    */
    // Unselect all bars
    function unselectAllBars() {
      lines.forEach((line) =>
        line.bars.forEach((bar) => (bar.selected = false))
      );
    }
    // Remove highlight class from any bars
    function clearHighlights() {
      document
        .querySelectorAll(".bar.highlighted")
        .forEach((el) => el.classList.remove("highlighted"));
    }

    /*
      ---------------------------------------------------------------------------------------------
      updateBarTextPositions => center the bar labels in their visible region
      ---------------------------------------------------------------------------------------------
    */
    function updateBarTextPositions() {
      let scrollLeft = tableWrapper.scrollLeft;   // Current horizontal scroll
      let viewportWidth = tableWrapper.clientWidth; // Visible width
      // For each bar-text, recenter it if bar is partially visible
      document.querySelectorAll(".bar-text").forEach((textEl) => {
        let barEl = textEl.parentElement; // The bar's container
        let barLeft = parseFloat(barEl.style.left);
        let barWidth = parseFloat(barEl.style.width);
        let barRight = barLeft + barWidth;

        // dynamic font => scale with bar width & rowHeight
        let dynamicFontSize = Math.min(
          barWidth * 0.15,
          rowHeight * 0.4
        );
        if (dynamicFontSize < 8) dynamicFontSize = 8; 
        textEl.style.fontSize = dynamicFontSize + "px";

        // We'll compute the visible portion
        let visibleLeft = Math.max(barLeft, scrollLeft);
        let visibleRight = Math.min(barRight, scrollLeft + viewportWidth);
        let visibleWidth = visibleRight - visibleLeft;
        if (visibleWidth <= 0) {
          textEl.style.opacity = "0";
          return;
        }
        textEl.style.opacity = "1";
        let textWidth = textEl.offsetWidth;
        let textLeft = visibleLeft - barLeft + (visibleWidth - textWidth) / 2;
        if (textLeft < 5) textLeft = 5;
        if (textLeft + textWidth > barWidth - 5) {
          textLeft = barWidth - textWidth - 5;
        }
        textEl.style.left = textLeft + "px";
      });
    }

    /*
      ---------------------------------------------------------------------------------------------
      renderHeader => builds 3-row date header for the Gantt
      ---------------------------------------------------------------------------------------------
    */
    function renderHeader() {
      const thead = ganttTable.querySelector("thead"); // Table header element
      thead.innerHTML = ""; // Clear existing

      let yearRow = document.createElement("tr");  // Row for years
      let monthRow = document.createElement("tr"); // Row for months
      let weekRow = document.createElement("tr");  // Row for weeks
      weekRow.id = "headerRow";

      // The "Tasks" heading cell
      const tasksTh = document.createElement("th");
      tasksTh.id = "nameHeader";
      tasksTh.rowSpan = 3;           // Spans 3 rows (year,month,week)
      tasksTh.textContent = "Personnel & Opps"; // Label
      tasksTh.classList.add("timescale-header");
      yearRow.appendChild(tasksTh);

      // Append rows to THEAD
      thead.appendChild(yearRow);
      thead.appendChild(monthRow);
      thead.appendChild(weekRow);

      let { displayStart, displayEnd } = getDisplayRange(); 
      let totalWeeks = displayEnd - displayStart + 1;
      if (totalWeeks < 1) return; // No timescale => stop

      // Build array of weeks for labeling
      let weekData = [];
      for (let i = 0; i < totalWeeks; i++) {
        let abs = displayStart + i;
        let { year, week } = fromAbsoluteWeek(abs);
        let mIdx = getMonthFromYearWeek(year, week);
        weekData.push({ abs, year, week, monthIndex: mIdx });
      }

      // Group by year
      let yearGroups = [];
      let currentYearGroup = null;
      for (let wd of weekData) {
        if (!currentYearGroup || currentYearGroup.year !== wd.year) {
          currentYearGroup = { year: wd.year, weeks: [] };
          yearGroups.push(currentYearGroup);
        }
        currentYearGroup.weeks.push(wd);
      }

      // For each year group, group by month
      for (let yg of yearGroups) {
        let monthGroups = [];
        let currentMonthGroup = null;
        for (let wd of yg.weeks) {
          if (!currentMonthGroup || currentMonthGroup.monthIndex !== wd.monthIndex) {
            currentMonthGroup = { monthIndex: wd.monthIndex, weeks: [] };
            monthGroups.push(currentMonthGroup);
          }
          currentMonthGroup.weeks.push(wd);
        }
        yg.monthGroups = monthGroups;
      }

      // Render year row
      for (let yg of yearGroups) {
        let th = document.createElement("th");
        th.textContent = yg.year;                   // Year label
        th.colSpan = yg.weeks.length;               // Spans the number of weeks in that year
        th.className = "timescale-header";

        let totalWidthForYear = yg.weeks.length * cellWidth; 
        th.style.width = totalWidthForYear + "px";
        let dynamicFontSizeYear = Math.max(20, Math.min(16, totalWidthForYear * 0.02));
        th.style.fontSize = dynamicFontSizeYear + "px";

        yearRow.appendChild(th);
      }

      // Render month row
      for (let yg of yearGroups) {
        for (let mg of yg.monthGroups) {
          let th = document.createElement("th");
          th.textContent = getMonthName(mg.monthIndex); 
          th.colSpan = mg.weeks.length;  
          th.className = "timescale-header";

          let totalWidthForMonth = mg.weeks.length * cellWidth;
          th.style.width = totalWidthForMonth + "px";
          let dynamicFontSizeMonth = Math.max(15, Math.min(16, totalWidthForMonth * 0.02));
          th.style.fontSize = dynamicFontSizeMonth + "px";

          monthRow.appendChild(th);
        }
      }

      // Render week row
      for (let wd of weekData) {
        let th = document.createElement("th");
        th.className = "timescale-header";
        th.style.width = cellWidth + "px";
        let dynamicFontSizeWeek = Math.max(8, Math.min(16, cellWidth * 0.2));
        th.style.fontSize = dynamicFontSizeWeek + "px";
        th.textContent = "W" + wd.week; 
        weekRow.appendChild(th);
      }
    }

    /*
      ---------------------------------------------------------------------------------------------
      handleBarClickSelect => shift/ctrl multi selection
      ---------------------------------------------------------------------------------------------
    */
    function handleBarClickSelect(bar, evt) {
      let multi = evt.shiftKey || evt.ctrlKey || evt.metaKey; 
      if (!multi) {
        unselectAllBars();      // Deselect all if not multi
        bar.selected = true;    // Select only this bar
      } else {
        bar.selected = !bar.selected; // Toggle if using multi
      }
    }

    /*
      ---------------------------------------------------------------------------------------------
      Sort helper to get earliest bar in a line for use with bar fields
      ---------------------------------------------------------------------------------------------
    */
    function getEarliestBar(line) {
      // If no bars, return null
      if (!line.bars.length) return null;
      // Sort a copy by startAbsWeek so earliest is first
      let sorted = [...line.bars].sort((a, b) => a.startAbsWeek - b.startAbsWeek);
      return sorted[0]; // earliest bar
    }
    function getEarliestBarValue(line, field) {
      let b = getEarliestBar(line);
      if (!b) return ""; 
      // If finishAbsWeek => startAbsWeek + length - 1
      if (field === "finishAbsWeek") {
        return b.startAbsWeek + b.length - 1;
      }
      // If numeric field => parse integer
      if (field === "startAbsWeek" || field === "length") {
        return parseInt(b[field]) || 0;
      }
      // Otherwise treat as string
      let val = b[field] || "";
      return val.toString().toLowerCase();
    }

    /*
      ---------------------------------------------------------------------------------------------
      Comparison helpers for stacked sorting
      ---------------------------------------------------------------------------------------------
    */
    function doLineCompare(lineA, lineB, field, direction) {
      // If no field, no difference
      if (!field) return 0;
      let valA, valB;

      // If sorting by lineType, compare line's own "type" attribute
      if (field === "lineType") {
        valA = (lineA.type || "").toLowerCase();
        valB = (lineB.type || "").toLowerCase();
      } else {
        // Otherwise compare earliest bar's value for that field
        valA = getEarliestBarValue(lineA, field);
        valB = getEarliestBarValue(lineB, field);
      }

      // Check if numeric
      let numA = parseFloat(valA);
      let numB = parseFloat(valB);
      let bothNumeric = !isNaN(numA) && !isNaN(numB);

      if (bothNumeric) {
        if (numA < numB) return direction === "asc" ? -1 : 1;
        if (numA > numB) return direction === "asc" ? 1 : -1;
        return 0;
      } else {
        // String compare
        if (valA < valB) return direction === "asc" ? -1 : 1;
        if (valA > valB) return direction === "asc" ? 1 : -1;
        return 0;
      }
    }
    function doBarCompare(barA, barB, field, direction) {
      // If no field, no difference
      if (!field) return 0;
      let valA, valB;

      // If sorting by bar's finishAbsWeek => start + length - 1
      if (field === "finishAbsWeek") {
        valA = barA.startAbsWeek + barA.length - 1;
        valB = barB.startAbsWeek + barB.length - 1;
      } else if (field === "startAbsWeek" || field === "length") {
        valA = parseInt(barA[field]) || 0;
        valB = parseInt(barB[field]) || 0;
      } else {
        // String-based field
        valA = (barA[field] || "").toString().toLowerCase();
        valB = (barB[field] || "").toString().toLowerCase();
      }

      // Compare numeric or string
      let numA = parseFloat(valA);
      let numB = parseFloat(valB);
      let bothNumeric = !isNaN(numA) && !isNaN(numB);

      if (bothNumeric) {
        if (numA < numB) return direction === "asc" ? -1 : 1;
        if (numA > numB) return direction === "asc" ? 1 : -1;
        return 0;
      } else {
        if (valA < valB) return direction === "asc" ? -1 : 1;
        if (valA > valB) return direction === "asc" ? 1 : -1;
        return 0;
      }
    }

    /*
      ---------------------------------------------------------------------------------------------
      renderTable => builds the main Gantt UI, includes stacked sorting logic
      ---------------------------------------------------------------------------------------------
    */
    function renderTable() {
      renderHeader();      // Rebuild header
      tableBody.innerHTML = ""; // Clear existing rows
      clearHighlights();   // Remove leftover highlights

      let { displayStart, displayEnd } = getDisplayRange();
      let totalWeeks = displayEnd - displayStart + 1;
      if (totalWeeks < 1) return; // No timescale => stop

      let lowerSearch = searchTerm.toLowerCase(); // Lowercase search term

      // Filter lines
      let filteredLines = lines.filter((line) => {
        // Check line filters
        if (Object.keys(filters.line).length > 0) {
          for (let f in filters.line) {
            let filterValue = filters.line[f].toLowerCase();
            if (!line[f] || !line[f].toLowerCase().includes(filterValue)) {
              return false;
            }
          }
        }
        // Check discipline slicer
        if (slicers.discipline) {
          if (Array.isArray(slicers.discipline)) {
            const discLower = line.discipline.toLowerCase();
            const selLowerArr = slicers.discipline.map(d => d.toLowerCase());
            if (!selLowerArr.includes(discLower)) return false;
          } else {
            if (line.discipline.toLowerCase() !== slicers.discipline.toLowerCase()) {
              return false;
            }
          }
        }
        // Check client slicer => line or bar
        if (slicers.client) {
          if (Array.isArray(slicers.client)) {
            let passAny = false;
            for (let cVal of slicers.client.map(c => c.toLowerCase())) {
              let lineMatchesClient =
                line.client && line.client.toLowerCase() === cVal;
              let barHasClient = line.bars.some(
                (b) => b.client && b.client.toLowerCase() === cVal
              );
              if (lineMatchesClient || barHasClient) {
                passAny = true;
                break;
              }
            }
            if (!passAny) return false;
          } else {
            const lineMatchesClient =
              line.client && line.client.toLowerCase() === slicers.client.toLowerCase();
            const barHasClient = line.bars.some(
              (b) => b.client && b.client.toLowerCase() === slicers.client.toLowerCase()
            );
            if (!lineMatchesClient && !barHasClient) {
              return false;
            }
          }
        }
        // Check experience slicer
        if (slicers.experience) {
          if (Array.isArray(slicers.experience)) {
            const exprLower = line.experience.toLowerCase();
            const selArr = slicers.experience.map(e => e.toLowerCase());
            if (!selArr.includes(exprLower)) {
              return false;
            }
          } else {
            if (line.experience.toLowerCase() !== slicers.experience.toLowerCase()) {
              return false;
            }
          }
        }
        // Check location slicer
        if (slicers.location) {
          if (Array.isArray(slicers.location)) {
            const locLower = line.officeLocation.toLowerCase();
            const selArr = slicers.location.map(l => l.toLowerCase());
            if (!selArr.includes(locLower)) {
              return false;
            }
          } else {
            if (line.officeLocation.toLowerCase() !== slicers.location.toLowerCase()) {
              return false;
            }
          }
        }

        // Check bar filters => any bar must pass
        let passBars = line.bars.filter((b) => {
          if (Object.keys(filters.bar).length > 0) {
            for (let fb in filters.bar) {
              let val = filters.bar[fb].toLowerCase();
              if (!b[fb] || !b[fb].toLowerCase().includes(val)) {
                return false;
              }
            }
          }
          return true;
        });
        if (
          Object.keys(filters.bar).length > 0 &&
          passBars.length === 0
        ) {
          return false; // No bar survived that filter => line fails
        }

        // Check text-based search => combine line fields & bar fields
        if (lowerSearch) {
          let lineMatch =
            (line.name && line.name.toLowerCase().includes(lowerSearch)) ||
            (line.client && line.client.toLowerCase().includes(lowerSearch)) ||
            (line.discipline && line.discipline.toLowerCase().includes(lowerSearch)) ||
            (line.experience && line.experience.toLowerCase().includes(lowerSearch)) ||
            (line.officeLocation && line.officeLocation.toLowerCase().includes(lowerSearch)) ||
            (line.geoLocation && line.geoLocation.toLowerCase().includes(lowerSearch)) ||
            (line.type && line.type.toLowerCase().includes(lowerSearch));

          let barMatch = line.bars.some((bar) => {
            let bFields = [
              (bar.label || "").toLowerCase(),
              (bar.projectName || "").toLowerCase(),
              (bar.client || "").toLowerCase(),
              (bar.discipline || "").toLowerCase(),
              (bar.experience || "").toLowerCase(),
              (bar.LOE || "").toLowerCase(),
              (bar.location || "").toLowerCase(),
              (bar.type || "").toLowerCase(),
              (bar.proposed || "").toLowerCase(),
              (bar.assignedTo || "").toLowerCase(),
            ];
            return bFields.some((f) => f.includes(lowerSearch));
          });
          if (!lineMatch && !barMatch) return false;
        }
        return true;
      });

      mainFilteredLines = filteredLines;

      // --------------------------------------------------------------------------------
      // LINES: apply primary & secondary sorting
      // --------------------------------------------------------------------------------
      if (barSortField || barSortField2) {
        mainFilteredLines.sort((lineA, lineB) => {
          // Compare by primary field
          let result = doLineCompare(lineA, lineB, barSortField, barSortDirection);
          // If tie, compare by secondary if provided
          if (result === 0 && barSortField2) {
            result = doLineCompare(lineA, lineB, barSortField2, barSortDirection2);
          }
          return result;
        });
      }

      // Build rows for each line
      mainFilteredLines.forEach((line, lineIndex) => {
        // --------------------------------------------------------------------------------
        // BARS: apply primary & secondary sorting for each line
        // --------------------------------------------------------------------------------
        if (barSortField || barSortField2) {
          line.bars.sort((barA, barB) => {
            let result = doBarCompare(barA, barB, barSortField, barSortDirection);
            if (result === 0 && barSortField2) {
              result = doBarCompare(barA, barB, barSortField2, barSortDirection2);
            }
            return result;
          });
        }

        const tr = document.createElement("tr"); // Row element
        tr.className = "gantt-row";
        if (line.selected) tr.classList.add("selected");
        if (line.dragging) tr.classList.add("drag-highlight");

        // The name cell => sticky left with line name
        const nameTd = document.createElement("td");
        nameTd.className = "name-cell";
        nameTd.addEventListener("mousedown", (e) =>
          onLineMouseDown(e, line, lineIndex)
        );
        nameTd.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          showLineEditor(line, e.clientX, e.clientY);
        });
        const labelSpan = document.createElement("span");
        labelSpan.textContent = line.name;
        nameTd.appendChild(labelSpan);
        tr.appendChild(nameTd);

        // The bar cell => spans totalWeeks
        const barTd = document.createElement("td");
        barTd.colSpan = totalWeeks;
        barTd.className = "bar-cell";
        const barContainer = document.createElement("div");
        barContainer.className = "bar-row-container";
        // Right-click on empty container => add bar (admin only)
        barContainer.addEventListener("contextmenu", (ev) => {
          if (adminMode) {
            if (
              !ev.target.classList.contains("bar") &&
              !ev.target.classList.contains("bar-text") &&
              !ev.target.classList.contains("bar-handle")
            ) {
              ev.preventDefault();
              barCounter++;
              let offsetX = ev.offsetX;
              let weeksFromStart = Math.floor(offsetX / cellWidth);
              let { displayStart } = getDisplayRange();
              let nb = {
                id: barCounter,
                label: "",
                projectName: "New Project",
                client: "",
                discipline: "",
                experience: "",
                LOE: "",
                location: "",
                assignedTo: "",
                proposed: "no",
                type: "proposed",
                startAbsWeek: displayStart + weeksFromStart,
                length: 4,
                selected: false,
                dragging: false,
              };
              line.bars.push(nb);
              pushState();
              renderTable();
              saveToLocalStorage();
            }
          }
        });

        // Filter which bars to display
        let finalBarsToRender = line.bars.filter((b) => {
          if (Object.keys(filters.bar).length > 0) {
            for (let fb in filters.bar) {
              let val = filters.bar[fb].toLowerCase();
              if (!b[fb] || !b[fb].toLowerCase().includes(val)) {
                return false;
              }
            }
          }
          return true;
        });

        // Place each bar in the container if it overlaps the display range
        finalBarsToRender.forEach((bar) => {
          let barStart = bar.startAbsWeek;  
          let barEnd = barStart + bar.length;
          let overlapStart = Math.max(displayStart, barStart);
          let overlapEnd = Math.min(displayEnd + 1, barEnd);
          let overlapLen = overlapEnd - overlapStart;
          if (overlapLen <= 0) return; // No overlap => skip

          let barLeftPx = (overlapStart - displayStart) * cellWidth;
          let barWidthPx = overlapLen * cellWidth;

          const barDiv = document.createElement("div");
          barDiv.classList.add("bar");
          if (bar.dragging) {
            barDiv.classList.add("drag-highlight");
          }
          // If search highlights bar
          if (
            lowerSearch &&
            (
              (bar.projectName || "").toLowerCase().includes(lowerSearch) ||
              (bar.assignedTo || "").toLowerCase().includes(lowerSearch)
            )
          ) {
            barDiv.classList.add("highlighted");
          }

          barDiv.style.left = barLeftPx + "px";
          barDiv.style.width = barWidthPx + "px";
          barDiv.style.backgroundColor = getColorFromType(bar.type);

          // The text element inside the bar
          const textSpan = document.createElement("span");
          textSpan.className = "bar-text";
          textSpan.textContent = bar.label || bar.projectName;
          barDiv.appendChild(textSpan);

          // If admin => show resize handles
          if (adminMode) {
            const leftHandle = document.createElement("div");
            leftHandle.classList.add("bar-handle", "left");
            const rightHandle = document.createElement("div");
            rightHandle.classList.add("bar-handle", "right");
            barDiv.appendChild(leftHandle);
            barDiv.appendChild(rightHandle);
          }

          // Right-click => bar editor
          barDiv.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            showBarEditor(bar, line, e.clientX, e.clientY);
          });
          // Click => select
          barDiv.addEventListener("click", (e) => {
            e.stopPropagation();
            handleBarClickSelect(bar, e);
            renderTable();
            saveToLocalStorage();
          });
          // Mousedown => drag bar if admin, or user move
          barDiv.addEventListener("mousedown", (e) =>
            onBarMouseDown(e, line, bar, lineIndex)
          );

          barContainer.appendChild(barDiv);
        });

        // Render overlap hatching
        let sorted = [...finalBarsToRender].sort((a, b) => a.startAbsWeek - b.startAbsWeek);
        for (let i = 0; i < sorted.length; i++) {
          for (let j = i + 1; j < sorted.length; j++) {
            let b1 = sorted[i];
            let b2 = sorted[j];
            let s1 = b1.startAbsWeek;
            let e1 = b1.startAbsWeek + b1.length;
            let s2 = b2.startAbsWeek;
            let e2 = b2.startAbsWeek + b2.length;
            let overlapS = Math.max(s1, s2);
            let overlapE = Math.min(e1, e2);
            if (overlapE > overlapS) {
              let leftPx = (Math.max(displayStart, overlapS) - displayStart) * cellWidth;
              let wPx =
                (Math.min(displayEnd + 1, overlapE) - Math.max(displayStart, overlapS)) *
                cellWidth;
              if (wPx > 0) {
                let hatch = document.createElement("div");
                hatch.className = "overlap-hatch";
                hatch.style.left = leftPx + "px";
                hatch.style.width = wPx + "px";
                barContainer.appendChild(hatch);
              }
            }
          }
        }

        barTd.appendChild(barContainer);
        tr.appendChild(barTd);
        tableBody.appendChild(tr);
      });

      updateBarTextPositions(); // Recenter text
    }

    /*
      ---------------------------------------------------------------------------------------------
      onLineMouseDown => reorder lines if admin
      ---------------------------------------------------------------------------------------------
    */
    function onLineMouseDown(e, line, lineIndex) {
      dragging = true;           // We are dragging now
      dragType = "line-reorder"; // Type => reorder lines
      draggingLine = line;       // Which line is being dragged
      line.dragging = true;      // Mark the line as dragging
      tableBodyRect = tableBody.getBoundingClientRect(); // For computing Y offset
      renderTable();             // Rerender to show highlight
      e.preventDefault();        // Prevent text selection
    }

    /*
      ---------------------------------------------------------------------------------------------
      onBarMouseDown => handle bar movement / resizing
      ---------------------------------------------------------------------------------------------
    */
    function onBarMouseDown(e, line, bar, lineIndex) {
      dragging = true;        // We are dragging
      currentBar = bar;       // Store the bar reference
      currentLine = line;     // Store the line reference
      dragStartX = e.clientX; // X pos at start
      dragStartY = e.clientY; // Y pos at start
      initialStartAbs = bar.startAbsWeek;  // Start absolute
      initialLength = bar.length;          // Original length
      tableBodyRect = tableBody.getBoundingClientRect(); // For vertical dragging
      bar.dragging = true;    // Mark bar as dragging

      if (adminMode) {
        if (e.target.classList.contains("bar-handle")) {
          if (e.target.classList.contains("left")) dragType = "resize-left";
          else dragType = "resize-right";
        } else {
          dragType = "bar-move-admin";
        }
      } else {
        dragType = "bar-move-user";
      }
      e.preventDefault(); // Prevent text selection
    }

    /*
      ---------------------------------------------------------------------------------------------
      MOUSEMOVE => handle dragging logic
      ---------------------------------------------------------------------------------------------
    */
    document.addEventListener("mousemove", (e) => {
      if (!dragging) return; // Only if currently dragging
      if (dragType === "line-reorder" && draggingLine) {
        let posY = e.clientY - tableBodyRect.top;
        let newIndex = Math.floor(posY / rowHeight);
        if (newIndex < 0) newIndex = 0;
        if (newIndex >= mainFilteredLines.length) newIndex = mainFilteredLines.length - 1;
        let oldIndex = mainFilteredLines.indexOf(draggingLine);
        if (oldIndex < 0) return;
        if (newIndex !== oldIndex) {
          // Remove from current position
          lines.splice(lines.indexOf(draggingLine), 1);
          // Insert near the target line
          let targetLine = mainFilteredLines[newIndex];
          let targetGlobalIdx = lines.indexOf(targetLine);
          if (targetGlobalIdx < 0) targetGlobalIdx = lines.length;
          lines.splice(targetGlobalIdx, 0, draggingLine);
          renderTable();
        }
      } else if (dragType === "bar-move-admin" && currentBar) {
        let dx = e.clientX - dragStartX;
        let dWeeks = Math.round(dx / cellWidth);
        currentBar.startAbsWeek = Math.max(0, initialStartAbs + dWeeks);

        let posY = e.clientY - tableBodyRect.top;
        let idxCur = mainFilteredLines.indexOf(currentLine);
        if (idxCur < 0) idxCur = 0;
        let newIdx = Math.floor(posY / rowHeight);
        if (newIdx < 0) newIdx = 0;
        if (newIdx >= mainFilteredLines.length) newIdx = mainFilteredLines.length - 1;
        if (newIdx !== idxCur) {
          currentLine.bars = currentLine.bars.filter((b) => b.id !== currentBar.id);
          mainFilteredLines[newIdx].bars.push(currentBar);
          currentLine = mainFilteredLines[newIdx];
        }
        renderTable();
      } else if (dragType === "resize-left" && currentBar) {
        let dx = e.clientX - dragStartX;
        let dWeeks = Math.round(dx / cellWidth);
        let newStart = initialStartAbs + dWeeks;
        let newLen = initialStartAbs + initialLength - newStart;
        if (newLen < 1) {
          newLen = 1;
          newStart = initialStartAbs + initialLength - 1;
        }
        currentBar.startAbsWeek = Math.max(0, newStart);
        currentBar.length = newLen;
        renderTable();
      } else if (dragType === "resize-right" && currentBar) {
        let dx = e.clientX - dragStartX;
        let dWeeks = Math.round(dx / cellWidth);
        let newLen = initialLength + dWeeks;
        if (newLen < 1) newLen = 1;
        currentBar.length = newLen;
        renderTable();
      } else if (dragType === "bar-move-user" && currentBar) {
        let posY = e.clientY - tableBodyRect.top;
        let newIndex = Math.floor(posY / rowHeight);
        if (newIndex < 0) newIndex = 0;
        if (newIndex >= mainFilteredLines.length) newIndex = mainFilteredLines.length - 1;
        let oldLineIdx = mainFilteredLines.indexOf(currentLine);
        if (oldLineIdx < 0) oldLineIdx = 0;
        if (newIndex !== oldLineIdx) {
          mainFilteredLines[oldLineIdx].bars = mainFilteredLines[oldLineIdx].bars.filter(
            (b) => b.id !== currentBar.id
          );
          mainFilteredLines[newIndex].bars.push(currentBar);
          currentLine = mainFilteredLines[newIndex];
          renderTable();
        }
      }
    });

    /*
      ---------------------------------------------------------------------------------------------
      MOUSEUP => finalize drag
      ---------------------------------------------------------------------------------------------
    */
    document.addEventListener("mouseup", () => {
      if (!dragging) return;
      dragging = false;
      if (dragType === "line-reorder") {
        draggingLine.dragging = false;
        draggingLine = null;
        pushState();
        saveToLocalStorage();
        renderTable();
      } else if (["bar-move-admin","resize-left","resize-right","bar-move-user"].includes(dragType)) {
        if (currentBar) {
          currentBar.dragging = false;
        }
        currentBar = null;
        currentLine = null;
        pushState();
        saveToLocalStorage();
      }
      dragType = null;
    });

    /*
      ---------------------------------------------------------------------------------------------
      Document click => unselect lines/bars if user clicks blank area
      ---------------------------------------------------------------------------------------------
    */
    document.addEventListener("click", (evt) => {
      if (!dragging) {
        let nm = evt.target.closest(".name-cell");
        let br = evt.target.closest(".bar");
        if (!nm && !br) {
          lines.forEach((l) => (l.selected = false));
          unselectAllBars();
          renderTable();
          saveToLocalStorage();
        }
      }
    });

    /*
      ---------------------------------------------------------------------------------------------
      showBarEditor => opens the bar properties editor
      ---------------------------------------------------------------------------------------------
    */
    function showBarEditor(bar, line, x, y) {
      currentEditorBar = bar;
      currentEditorLine = line;
      barLabelInput.value = bar.label || "";
      barProjectNameInput.value = bar.projectName || "";
      barClientInput.value = bar.client || "";
      barDisciplineInput.value = bar.discipline || "";
      barExperienceInput.value = bar.experience || "";
      barLOEInput.value = bar.LOE || "";
      barLocationInput.value = bar.location || "";
      barAssignedToInput.value = bar.assignedTo || "";
      barTypeSelect.value = bar.type || "proposed";
      barProposedSelect.value = bar.proposed || "no";

      let { year: sy, week: sw } = fromAbsoluteWeek(bar.startAbsWeek);
      let { year: ey, week: ew } = fromAbsoluteWeek(bar.startAbsWeek + bar.length - 1);
      startYearSelect.value = sy;
      startWeekSelect.value = sw;
      endYearSelect.value = ey;
      endWeekSelect.value = ew;

      let ro = !adminMode; // If not admin => readOnly
      [
        barLabelInput,
        barProjectNameInput,
        barClientInput,
        barDisciplineInput,
        barExperienceInput,
        barLOEInput,
        barLocationInput,
        barAssignedToInput,
        barTypeSelect,
        barProposedSelect,
        startYearSelect,
        startWeekSelect,
        endYearSelect,
        endWeekSelect,
        barDeleteBtn,
      ].forEach((el) => (el.disabled = ro));

      barEditor.style.display = "block";
      barEditor.style.left = x + window.scrollX + 10 + "px";
      barEditor.style.top = y + window.scrollY + 10 + "px";

      // Reposition if it goes off screen
      setTimeout(() => {
        let rect = barEditor.getBoundingClientRect();
        if (rect.right > window.innerWidth) {
          barEditor.style.left = Math.max(0, window.innerWidth - rect.width - 10) + "px";
        }
        if (rect.bottom > window.innerHeight) {
          barEditor.style.top = Math.max(0, window.innerHeight - rect.height - 10) + "px";
        }
      }, 0);

      // If admin => auto-apply changes to bar
      const autosave = () => {
        if (!adminMode) return;
        currentEditorBar.label = barLabelInput.value;
        currentEditorBar.projectName = barProjectNameInput.value;
        currentEditorBar.client = barClientInput.value;
        currentEditorBar.discipline = barDisciplineInput.value;
        currentEditorBar.experience = barExperienceInput.value;
        currentEditorBar.LOE = barLOEInput.value;
        currentEditorBar.location = barLocationInput.value;
        currentEditorBar.assignedTo = barAssignedToInput.value;
        currentEditorBar.type = barTypeSelect.value;
        currentEditorBar.proposed = barProposedSelect.value;

        let sY = parseInt(startYearSelect.value);
        let sW = parseInt(startWeekSelect.value);
        let eY = parseInt(endYearSelect.value);
        let eW = parseInt(endWeekSelect.value);
        currentEditorBar.startAbsWeek = toAbsoluteWeek(sY, sW);
        currentEditorBar.length = toAbsoluteWeek(eY, eW) - currentEditorBar.startAbsWeek + 1;
        if (currentEditorBar.length < 1) currentEditorBar.length = 1;
        renderTable();
        saveToLocalStorage();
      };
      // Attach the autosave to each input change if admin
      barLabelInput.oninput = autosave;
      barProjectNameInput.oninput = autosave;
      barClientInput.oninput = autosave;
      barDisciplineInput.oninput = autosave;
      barExperienceInput.oninput = autosave;
      barLOEInput.oninput = autosave;
      barLocationInput.oninput = autosave;
      barAssignedToInput.oninput = autosave;
      barTypeSelect.onchange = autosave;
      barProposedSelect.onchange = autosave;
      startYearSelect.onchange = autosave;
      startWeekSelect.onchange = autosave;
      endYearSelect.onchange = autosave;
      endWeekSelect.onchange = autosave;
    }

    // Bar editor OK => close editor
    barEditorOkBtn.addEventListener("click", () => {
      barEditor.style.display = "none";
      currentEditorBar = null;
      currentEditorLine = null;
      pushState();
    });
    // Bar editor Cancel => close editor
    barEditorCancelBtn.addEventListener("click", () => {
      barEditor.style.display = "none";
      currentEditorBar = null;
      currentEditorLine = null;
      pushState();
    });
    // Delete Bar => remove from line
    barDeleteBtn.addEventListener("click", () => {
      if (!adminMode) return;
      if (!currentEditorBar || !currentEditorLine) return;
      currentEditorLine.bars = currentEditorLine.bars.filter((b) => b.id !== currentEditorBar.id);
      barEditor.style.display = "none";
      currentEditorBar = null;
      currentEditorLine = null;
      pushState();
      renderTable();
      saveToLocalStorage();
    });
    // If click outside barEditor => hide
    document.addEventListener("mousedown", (e) => {
      if (barEditor.style.display === "block") {
        let rect = barEditor.getBoundingClientRect();
        let inside =
          e.clientX >= rect.left &&
          e.clientX <= rect.right &&
          e.clientY >= rect.top &&
          e.clientY <= rect.bottom;
        if (!inside) {
          barEditor.style.display = "none";
          currentEditorBar = null;
          currentEditorLine = null;
          pushState();
        }
      }
    });

    /*
      ---------------------------------------------------------------------------------------------
      showLineEditor => opens the line editor for name, discipline, etc.
      ---------------------------------------------------------------------------------------------
    */
    function showLineEditor(line, x, y) {
      currentEditorLine = line;
      lineNameInput.value = line.name || "";
      lineClientInput.value = line.client || "";
      lineDisciplineInput.value = line.discipline || "";
      lineExperienceInput.value = line.experience || "";
      lineOfficeLocationInput.value = line.officeLocation || "";
      lineGeoLocationInput.value = line.geoLocation || "";
      lineTypeInput.value = line.type || "";

      let ro = !adminMode; // If not admin => readOnly
      [
        lineNameInput,
        lineClientInput,
        lineDisciplineInput,
        lineExperienceInput,
        lineOfficeLocationInput,
        lineGeoLocationInput,
        lineTypeInput,
        lineDeleteBtn,
      ].forEach((el) => (el.disabled = ro));

      lineEditor.style.display = "block";
      lineEditor.style.left = x + window.scrollX + 10 + "px";
      lineEditor.style.top = y + window.scrollY + 10 + "px";

      // Reposition if it goes off the screen
      setTimeout(() => {
        let rect = lineEditor.getBoundingClientRect();
        if (rect.right > window.innerWidth) {
          lineEditor.style.left = Math.max(0, window.innerWidth - rect.width - 10) + "px";
        }
        if (rect.bottom > window.innerHeight) {
          lineEditor.style.top = Math.max(0, window.innerHeight - rect.height - 10) + "px";
        }
      }, 0);

      // If admin => auto-apply changes
      const autosaveLine = () => {
        if (!adminMode) return;
        currentEditorLine.name = lineNameInput.value;
        currentEditorLine.client = lineClientInput.value;
        currentEditorLine.discipline = lineDisciplineInput.value;
        currentEditorLine.experience = lineExperienceInput.value;
        currentEditorLine.officeLocation = lineOfficeLocationInput.value;
        currentEditorLine.geoLocation = lineGeoLocationInput.value;
        currentEditorLine.type = lineTypeInput.value;
        renderTable();
        saveToLocalStorage();
      };
      lineNameInput.oninput = autosaveLine;
      lineClientInput.oninput = autosaveLine;
      lineDisciplineInput.oninput = autosaveLine;
      lineExperienceInput.oninput = autosaveLine;
      lineOfficeLocationInput.oninput = autosaveLine;
      lineGeoLocationInput.oninput = autosaveLine;
      lineTypeInput.oninput = autosaveLine;
    }

    // Line editor OK => close
    lineEditorOkBtn.addEventListener("click", () => {
      lineEditor.style.display = "none";
      currentEditorLine = null;
      pushState();
    });
    lineEditorCancelBtn.addEventListener("click", () => {
      lineEditor.style.display = "none";
      currentEditorLine = null;
      pushState();
    });
    // Delete line => remove from lines
    lineDeleteBtn.addEventListener("click", () => {
      if (!adminMode) return;
      if (!currentEditorLine) return;
      lines = lines.filter((l) => l.id !== currentEditorLine.id);
      lineEditor.style.display = "none";
      currentEditorLine = null;
      pushState();
      renderTable();
      saveToLocalStorage();
    });
    // If click outside line editor => close
    document.addEventListener("mousedown", (e) => {
      if (lineEditor.style.display === "block") {
        let rect = lineEditor.getBoundingClientRect();
        let inside =
          e.clientX >= rect.left &&
          e.clientX <= rect.right &&
          e.clientY >= rect.top &&
          e.clientY <= rect.bottom;
        if (!inside) {
          lineEditor.style.display = "none";
          currentEditorLine = null;
          pushState();
        }
      }
    });

    /*
      ---------------------------------------------------------------------------------------------
      Slicer logic => discipline/client/experience/location
      ---------------------------------------------------------------------------------------------
    */
    const slicerDisciplineSelect = document.getElementById("slicerDisciplineSelect");
    const slicerClientSelect = document.getElementById("slicerClientSelect");
    const slicerExperienceSelect = document.getElementById("slicerExperienceSelect");
    const slicerLocationSelect = document.getElementById("slicerLocationSelect");

    // Clear slicer selections => reset
    document.getElementById("clearDisciplineSlicerBtn").addEventListener("click", () => {
      slicers.discipline = null;
      Array.from(slicerDisciplineSelect.options).forEach(o => (o.selected = false));
      renderTable();
    });
    document.getElementById("clearClientSlicerBtn").addEventListener("click", () => {
      slicers.client = null;
      Array.from(slicerClientSelect.options).forEach(o => (o.selected = false));
      renderTable();
    });
    document.getElementById("clearExperienceSlicerBtn").addEventListener("click", () => {
      slicers.experience = null;
      Array.from(slicerExperienceSelect.options).forEach(o => (o.selected = false));
      renderTable();
    });
    document.getElementById("clearLocationSlicerBtn").addEventListener("click", () => {
      slicers.location = null;
      Array.from(slicerLocationSelect.options).forEach(o => (o.selected = false));
      renderTable();
    });

    // On change => store selected array, then rerender
    slicerDisciplineSelect.addEventListener("change", () => {
      const selectedOptions = Array.from(slicerDisciplineSelect.selectedOptions)
        .map(o => o.value)
        .filter(v => v !== "");
      slicers.discipline = selectedOptions.length > 0 ? selectedOptions : null;
      renderTable();
    });
    slicerClientSelect.addEventListener("change", () => {
      const selectedOptions = Array.from(slicerClientSelect.selectedOptions)
        .map(o => o.value)
        .filter(v => v !== "");
      slicers.client = selectedOptions.length > 0 ? selectedOptions : null;
      renderTable();
    });
    slicerExperienceSelect.addEventListener("change", () => {
      const selectedOptions = Array.from(slicerExperienceSelect.selectedOptions)
        .map(o => o.value)
        .filter(v => v !== "");
      slicers.experience = selectedOptions.length > 0 ? selectedOptions : null;
      renderTable();
    });
    slicerLocationSelect.addEventListener("change", () => {
      const selectedOptions = Array.from(slicerLocationSelect.selectedOptions)
        .map(o => o.value)
        .filter(v => v !== "");
      slicers.location = selectedOptions.length > 0 ? selectedOptions : null;
      renderTable();
    });

    // Build slicers from lines data
    function populateSlicers() {
      let disciplineSet = new Set();
      let clientSet = new Set();
      let experienceSet = new Set();
      let locationSet = new Set();

      lines.forEach((line) => {
        if (line.discipline) disciplineSet.add(line.discipline);
        if (line.client) clientSet.add(line.client);
        if (line.experience) experienceSet.add(line.experience);
        if (line.officeLocation) locationSet.add(line.officeLocation);

        line.bars.forEach((b) => {
          if (b.client) clientSet.add(b.client);
        });
      });

      let discArr = [...disciplineSet].sort();
      let clientArr = [...clientSet].sort();
      let expArr = [...experienceSet].sort();
      let locArr = [...locationSet].sort();

      function buildOptions(options) {
        return (
          options.map((o) => `<option value="${o}">${o}</option>`).join("")+`<option value=""></option>` 
        );
      }
      slicerDisciplineSelect.innerHTML = buildOptions(discArr);
      slicerClientSelect.innerHTML = buildOptions(clientArr);
      slicerExperienceSelect.innerHTML = buildOptions(expArr);
      slicerLocationSelect.innerHTML = buildOptions(locArr);
    }

    /*
      ---------------------------------------------------------------------------------------------
      Dynamic Filter => line/bar
      ---------------------------------------------------------------------------------------------
    */
    const filterLineName = document.getElementById("filterLineName");
    const filterLineClient = document.getElementById("filterLineClient");
    const filterLineDiscipline = document.getElementById("filterLineDiscipline");
    const filterLineExperience = document.getElementById("filterLineExperience");
    const filterLineOfficeLocation = document.getElementById("filterLineOfficeLocation");
    const filterLineGeoLocation = document.getElementById("filterLineGeoLocation");
    const filterLineType = document.getElementById("filterLineType");

    const filterBarProjectName = document.getElementById("filterBarProjectName");
    const filterBarClient = document.getElementById("filterBarClient");
    const filterBarDiscipline = document.getElementById("filterBarDiscipline");
    const filterBarExperience = document.getElementById("filterBarExperience");
    const filterBarLOE = document.getElementById("filterBarLOE");
    const filterBarLocation = document.getElementById("filterBarLocation");
    const filterBarAssignedTo = document.getElementById("filterBarAssignedTo");
    const filterBarType = document.getElementById("filterBarType");
    const filterBarProposed = document.getElementById("filterBarProposed");

    // Build filter dropdowns from line & bar data
    function populateFilterDropdowns() {
      let setLineName = new Set();
      let setLineClient = new Set();
      let setLineDiscipline = new Set();
      let setLineExperience = new Set();
      let setLineOffice = new Set();
      let setLineGeo = new Set();
      let setLineType = new Set();

      let setBarProject = new Set();
      let setBarClient = new Set();
      let setBarDiscipline = new Set();
      let setBarExperience = new Set();
      let setBarLOE = new Set();
      let setBarLocation = new Set();
      let setBarAssigned = new Set();
      let setBarType = new Set();
      let setBarProposed = new Set();

      lines.forEach((l) => {
        if (l.name) setLineName.add(l.name);
        if (l.client) setLineClient.add(l.client);
        if (l.discipline) setLineDiscipline.add(l.discipline);
        if (l.experience) setLineExperience.add(l.experience);
        if (l.officeLocation) setLineOffice.add(l.officeLocation);
        if (l.geoLocation) setLineGeo.add(l.geoLocation);
        if (l.type) setLineType.add(l.type);

        l.bars.forEach((b) => {
          if (b.projectName) setBarProject.add(b.projectName);
          if (b.client) setBarClient.add(b.client);
          if (b.discipline) setBarDiscipline.add(b.discipline);
          if (b.experience) setBarExperience.add(b.experience);
          if (b.LOE) setBarLOE.add(b.LOE);
          if (b.location) setBarLocation.add(b.location);
          if (b.assignedTo) setBarAssigned.add(b.assignedTo);
          if (b.type) setBarType.add(b.type);
          if (b.proposed) setBarProposed.add(b.proposed);
        });
      });

      let arrLineName = [...setLineName].sort();
      let arrLineClient = [...setLineClient].sort();
      let arrLineDiscipline = [...setLineDiscipline].sort();
      let arrLineExperience = [...setLineExperience].sort();
      let arrLineOffice = [...setLineOffice].sort();
      let arrLineGeo = [...setLineGeo].sort();
      let arrLineType = [...setLineType].sort();

      let arrBarProject = [...setBarProject].sort();
      let arrBarClient = [...setBarClient].sort();
      let arrBarDiscipline = [...setBarDiscipline].sort();
      let arrBarExperience = [...setBarExperience].sort();
      let arrBarLOE = [...setBarLOE].sort();
      let arrBarLocation = [...setBarLocation].sort();
      let arrBarAssigned = [...setBarAssigned].sort();
      let arrBarType = [...setBarType].sort();
      let arrBarProposed = [...setBarProposed].sort();

      function buildOptions(options) {
        return (
          `<option value=""></option>` +
          options.map((o) => `<option value="${o}">${o}</option>`).join("")
        );
      }
      filterLineName.innerHTML = buildOptions(arrLineName);
      filterLineClient.innerHTML = buildOptions(arrLineClient);
      filterLineDiscipline.innerHTML = buildOptions(arrLineDiscipline);
      filterLineExperience.innerHTML = buildOptions(arrLineExperience);
      filterLineOfficeLocation.innerHTML = buildOptions(arrLineOffice);
      filterLineGeoLocation.innerHTML = buildOptions(arrLineGeo);
      filterLineType.innerHTML = buildOptions(arrLineType);

      filterBarProjectName.innerHTML = buildOptions(arrBarProject);
      filterBarClient.innerHTML = buildOptions(arrBarClient);
      filterBarDiscipline.innerHTML = buildOptions(arrBarDiscipline);
      filterBarExperience.innerHTML = buildOptions(arrBarExperience);
      filterBarLOE.innerHTML = buildOptions(arrBarLOE);
      filterBarLocation.innerHTML = buildOptions(arrBarLocation);
      filterBarAssignedTo.innerHTML = buildOptions(arrBarAssigned);
      filterBarType.innerHTML = buildOptions(arrBarType);
      filterBarProposed.innerHTML = buildOptions(arrBarProposed);
    }

    // On any filter change => store results & rerender
    function autoRefreshFilters() {
      filters.line.name = filterLineName.value || null;
      filters.line.client = filterLineClient.value || null;
      filters.line.discipline = filterLineDiscipline.value || null;
      filters.line.experience = filterLineExperience.value || null;
      filters.line.officeLocation = filterLineOfficeLocation.value || null;
      filters.line.geoLocation = filterLineGeoLocation.value || null;
      filters.line.type = filterLineType.value || null;

      filters.bar.projectName = filterBarProjectName.value || null;
      filters.bar.client = filterBarClient.value || null;
      filters.bar.discipline = filterBarDiscipline.value || null;
      filters.bar.experience = filterBarExperience.value || null;
      filters.bar.LOE = filterBarLOE.value || null;
      filters.bar.location = filterBarLocation.value || null;
      filters.bar.assignedTo = filterBarAssignedTo.value || null;
      filters.bar.type = filterBarType.value || null;
      filters.bar.proposed = filterBarProposed.value || null;

      for (let k in filters.line) if (!filters.line[k]) delete filters.line[k];
      for (let k in filters.bar) if (!filters.bar[k]) delete filters.bar[k];
      renderTable();
    }

    [
      filterLineName,
      filterLineClient,
      filterLineDiscipline,
      filterLineExperience,
      filterLineOfficeLocation,
      filterLineGeoLocation,
      filterLineType,
      filterBarProjectName,
      filterBarClient,
      filterBarDiscipline,
      filterBarExperience,
      filterBarLOE,
      filterBarLocation,
      filterBarAssignedTo,
      filterBarType,
      filterBarProposed,
    ].forEach((el) => {
      el.addEventListener("change", autoRefreshFilters);
    });

    /*
      ---------------------------------------------------------------------------------------------
      FILTER modal => "Filter" button triggers it
      ---------------------------------------------------------------------------------------------
    */
    filterBtn.addEventListener("click", () => {
      populateFilterDropdowns();   // Refresh lists
      // Load existing filter values
      filterLineName.value = filters.line.name || "";
      filterLineClient.value = filters.line.client || "";
      filterLineDiscipline.value = filters.line.discipline || "";
      filterLineExperience.value = filters.line.experience || "";
      filterLineOfficeLocation.value = filters.line.officeLocation || "";
      filterLineGeoLocation.value = filters.line.geoLocation || "";
      filterLineType.value = filters.line.type || "";

      filterBarProjectName.value = filters.bar.projectName || "";
      filterBarClient.value = filters.bar.client || "";
      filterBarDiscipline.value = filters.bar.discipline || "";
      filterBarExperience.value = filters.bar.experience || "";
      filterBarLOE.value = filters.bar.LOE || "";
      filterBarLocation.value = filters.bar.location || "";
      filterBarAssignedTo.value = filters.bar.assignedTo || "";
      filterBarType.value = filters.bar.type || "";
      filterBarProposed.value = filters.bar.proposed || "";
      filterModal.style.display = "block";
    });
    filterApplyBtn.addEventListener("click", () => {
      filterModal.style.display = "none";
    });
    filterClearBtn.addEventListener("click", () => {
      filters.line = {};
      filters.bar = {};
      filterModal.style.display = "none";
      renderTable();
    });
    filterCancelBtn.addEventListener("click", () => {
      filterModal.style.display = "none";
    });
    document.addEventListener("mousedown", (e) => {
      if (filterModal.style.display === "block") {
        let rect = filterModal.getBoundingClientRect();
        let inside =
          e.clientX >= rect.left &&
          e.clientX <= rect.right &&
          e.clientY >= rect.top &&
          e.clientY <= rect.bottom;
        if (!inside) filterModal.style.display = "none";
      }
    });

    /*
      ---------------------------------------------------------------------------------------------
      THEME => settings modal
      ---------------------------------------------------------------------------------------------
    */
    const settingsModal = document.getElementById("settingsModal");
    const settingsOkBtn = document.getElementById("settingsOkBtn");
    const settingsCancelBtn = document.getElementById("settingsCancelBtn");
    const themeSelect = document.getElementById("themeSelect");
    const securedColor = document.getElementById("securedColor");
    const proposedColor = document.getElementById("proposedColor");
    const opportunityColor = document.getElementById("opportunityColor");
    const futureColor = document.getElementById("futureColor");

    document.getElementById("themeToggleBtn").addEventListener("click", () => {
      themeSelect.value = currentTheme;  // Preload current theme
      securedColor.value = typeColors.secured;
      proposedColor.value = typeColors.proposed;
      opportunityColor.value = typeColors.opportunity;
      futureColor.value = typeColors.future;
      settingsModal.style.display = "block";
    });
    settingsOkBtn.addEventListener("click", () => {
      currentTheme = themeSelect.value;          // Store selected theme
      typeColors.secured = securedColor.value;   // Store chosen color
      typeColors.proposed = proposedColor.value;
      typeColors.opportunity = opportunityColor.value;
      typeColors.future = futureColor.value;
      settingsModal.style.display = "none";      // Hide modal
      applyTheme();                              // Apply changes
    });
    settingsCancelBtn.addEventListener("click", () => {
      settingsModal.style.display = "none";      // Hide without changes
    });
    document.addEventListener("mousedown", (e) => {
      if (settingsModal.style.display === "block") {
        let rect = settingsModal.getBoundingClientRect();
        let inside =
          e.clientX >= rect.left &&
          e.clientX <= rect.right &&
          e.clientY >= rect.top &&
          e.clientY <= rect.bottom;
        if (!inside) settingsModal.style.display = "none";
      }
    });

    /*
      ---------------------------------------------------------------------------------------------
      ABOUT => simple alert
      ---------------------------------------------------------------------------------------------
    */
    document.getElementById("aboutToggleBtn").addEventListener("click", () => {
      alert(
        ` Sleek Professional Gantt Planner 
 Image placeholder added at left of toolbar. 
 Bar text vertically centered with dynamic font size. 
 Timescale from chosen Start date to 10 years later. 
Enjoy planning!
`
      );
    });

    /*
      ---------------------------------------------------------------------------------------------
      SEARCH => text input to filter lines & bars
      ---------------------------------------------------------------------------------------------
    */
    const searchInput = document.getElementById("searchInput");
    searchInput.addEventListener("input", () => {
      searchTerm = searchInput.value.trim(); // Update global search
      renderTable();                         // Re-render
    });

    /*
      ---------------------------------------------------------------------------------------------
      ADMIN TOGGLE => prompt for password, reveal advanced features
      ---------------------------------------------------------------------------------------------
    */
    const adminToggleBtn = document.getElementById("adminToggleBtn");
    const addItemsGroup = document.getElementById("addItemsGroup");
    adminToggleBtn.addEventListener("click", () => {
      if (!adminMode) {
        let pwd = prompt("Enter admin password:");
        if (pwd === "Password") {
          adminMode = true;
          alert("Admin mode enabled.");
        } else {
          alert("Incorrect password. Remaining in user mode.");
          return;
        }
      } else {
        adminMode = false;
        alert("Admin mode disabled.");
      }
      addItemsGroup.style.display = adminMode ? "block" : "none";
      csvEditToggleBtn.style.display = adminMode ? "inline-block" : "none";
      renderTable();
    });

    /*
      ---------------------------------------------------------------------------------------------
      CSV BUILD FUNCTION => eliminates repetitive code
      ---------------------------------------------------------------------------------------------
    */
    function buildCsv(linesArray) {
      // Build header
      let csvStr =
        "Line ID,Line Name,Line Client,Line Discipline,Line Experience,Line OfficeLocation,Line GeoLocation,Line Type," +
        "Bar ID,Bar Label,Project Name,Client,Discipline,Experience,LOE,Location,Assigned to,Proposed,Type," +
        "Start Year,Start Week,End Year,End Week,Duration (weeks)\n";
      
      // Each line => if no bars, blank columns for bar
      linesArray.forEach((line) => {
        if (!line.bars.length) {
          csvStr += `${line.id || ""},"${line.name || ""}","${line.client || ""}","${line.discipline || ""}","${line.experience || ""}","${line.officeLocation || ""}","${line.geoLocation || ""}","${line.type || ""}",,,,,,,,,,,,\n`;
        } else {
          // Each bar => form a row
          line.bars.forEach((bar) => {
            let { year: sy, week: sw } = fromAbsoluteWeek(bar.startAbsWeek);
            let { year: ey, week: ew } = fromAbsoluteWeek(bar.startAbsWeek + bar.length - 1);
            csvStr += `${line.id || ""},"${line.name || ""}","${line.client || ""}","${line.discipline || ""}","${line.experience || ""}","${line.officeLocation || ""}","${line.geoLocation || ""}","${line.type || ""}",`;
            csvStr += `${bar.id || ""},"${bar.label || ""}","${bar.projectName || ""}","${bar.client || ""}","${bar.discipline || ""}","${bar.experience || ""}","${bar.LOE || ""}","${bar.location || ""}","${bar.assignedTo || ""}","${bar.proposed || ""}","${bar.type || ""}",`;
            csvStr += `${sy},${sw},${ey},${ew},${bar.length}\n`;
          });
        }
      });
      return csvStr;
    }

    /*
      ---------------------------------------------------------------------------------------------
      CSV EDIT => show the entire CSV in a text area (admin only)
      ---------------------------------------------------------------------------------------------
    */
    const csvEditToggleBtn = document.getElementById("csvEditToggleBtn");
    const csvEditModal = document.getElementById("csvEditModal");
    const csvTextarea = document.getElementById("csvTextarea");
    const csvEditApplyBtn = document.getElementById("csvEditApplyBtn");
    const csvEditCancelBtn = document.getElementById("csvEditCancelBtn");

    csvEditToggleBtn.addEventListener("click", () => {
      if (!adminMode) return;
      // Build CSV from lines
      let csvStr = buildCsv(lines);
      // Put in textarea
      csvTextarea.value = csvStr;
      // Show modal
      csvEditModal.style.display = "block";
    });

    csvEditApplyBtn.addEventListener("click", () => {
      if (!adminMode) return;
      let csvData = csvTextarea.value;
      try {
        // Parse CSV data
        let parsed = parseCsv(csvData);
        // Overwrite lines with parsed result
        lines = parsed.lines;
        lineCounter = parsed.lineCounter;
        barCounter = parsed.barCounter;
        pushState();
        renderTable();
        saveToLocalStorage();
        alert("CSV updated successfully.");
        csvEditModal.style.display = "none";
      } catch (err) {
        alert("Error parsing CSV: " + err.message);
      }
    });
    csvEditCancelBtn.addEventListener("click", () => {
      csvEditModal.style.display = "none";
    });
    document.addEventListener("mousedown", (e) => {
      if (csvEditModal.style.display === "block") {
        let rect = csvEditModal.getBoundingClientRect();
        let inside =
          e.clientX >= rect.left &&
          e.clientX <= rect.right &&
          e.clientY >= rect.top &&
          e.clientY <= rect.bottom;
        if (!inside) csvEditModal.style.display = "none";
      }
    });

    /*
      ---------------------------------------------------------------------------------------------
      IMPORT => CSV
      ---------------------------------------------------------------------------------------------
    */
    const importCsvBtn = document.getElementById("importCsvBtn");
    const importFileInput = document.getElementById("importFileInput");
    importCsvBtn.addEventListener("click", () => {
      importFileInput.value = "";
      importFileInput.click();
    });
    importFileInput.addEventListener("change", (e) => {
      let file = e.target.files[0];
      if (!file) return;
      let reader = new FileReader();
      reader.onload = (ev) => {
        try {
          if (file.name.endsWith(".csv")) {
            let parsed = parseCsv(ev.target.result);
            lines = parsed.lines;
            lineCounter = parsed.lineCounter;
            barCounter = parsed.barCounter;
          } else {
            throw new Error("Unsupported file type (CSV only).");
          }

          startYearInput.value = startYear;
          startWeekInput.value = startWeek;
          endYear = startYear + 10; 
          endWeek = 52;

          zoomSlider.value = cellWidth;
          heightZoomSlider.value = rowHeight;
          themeSelect.value = currentTheme;
          securedColor.value = typeColors.secured;
          proposedColor.value = typeColors.proposed;
          opportunityColor.value = typeColors.opportunity;
          futureColor.value = typeColors.future;

          updateCSSVariables();
          applyTheme();
          renderTable();
          saveToLocalStorage();
          alert("CSV Import successful!");
        } catch (err) {
          console.error(err);
          alert("Import failed: " + err.message);
        }
      };
      reader.readAsText(file);
    });

    /*
      ---------------------------------------------------------------------------------------------
      CSV => minimal columns => "Export CSV" button
      ---------------------------------------------------------------------------------------------
    */
    const downloadCsvBtn = document.getElementById("downloadCsvBtn");
    downloadCsvBtn.addEventListener("click", () => {
      // Use the new buildCsv function
      let csv = buildCsv(lines);
      // Create blob
      let blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      let url = URL.createObjectURL(blob);
      let a = document.createElement("a");
      a.download = "gantt-data.csv";
      a.href = url;
      a.click();
      URL.revokeObjectURL(url);
    });

    /*
      ---------------------------------------------------------------------------------------------
      PRINT => Print/PDF
      ---------------------------------------------------------------------------------------------
    */
    const printBtn = document.getElementById("printBtn");
    printBtn.addEventListener("click", () => {
      window.print();
    });

    /*
      ---------------------------------------------------------------------------------------------
      ZOOM => horizontal (cellWidth) and vertical (rowHeight)
      ---------------------------------------------------------------------------------------------
    */
    const zoomSlider = document.getElementById("zoomSlider");
    const heightZoomSlider = document.getElementById("heightZoomSlider");
    zoomSlider.addEventListener("input", (e) => {
      cellWidth = parseInt(e.target.value);
      pushState();
      updateCSSVariables();
      renderTable();
      saveToLocalStorage();
    });
    heightZoomSlider.addEventListener("input", (e) => {
      rowHeight = parseInt(e.target.value);
      pushState();
      updateCSSVariables();
      renderTable();
      saveToLocalStorage();
    });

    /*
      ---------------------------------------------------------------------------------------------
      UNDO/REDO => admin only
      ---------------------------------------------------------------------------------------------
    */
    // Push current state to undo stack
    function pushState() {
      let st = JSON.parse(
        JSON.stringify({
          lines,
          startYear,
          startWeek,
          endYear,
          endWeek,
          lineCounter,
          barCounter,
          cellWidth,
          rowHeight,
          typeColors,
          currentTheme,
        })
      );
      undoStack.push(st);
      redoStack = [];
    }
    // Restore state from a snapshot
    function restoreState(st) {
      lines = st.lines;
      startYear = st.startYear;
      startWeek = st.startWeek;
      endYear = st.endYear;
      endWeek = st.endWeek;
      lineCounter = st.lineCounter;
      barCounter = st.barCounter;
      cellWidth = st.cellWidth;
      rowHeight = st.rowHeight;
      typeColors = st.typeColors;
      currentTheme = st.currentTheme;
      updateCSSVariables();
      applyTheme();
      renderTable();
      saveToLocalStorage();
    }
    // Undo => pop from undoStack
    function undo() {
      if (!adminMode) return;
      if (undoStack.length < 2) return; // Need at least 2 states
      let cur = undoStack.pop(); // Current
      redoStack.push(cur);       // Move current to redo stack
      let prev = undoStack[undoStack.length - 1];
      restoreState(prev);
    }
    // Redo => pop from redoStack
    function redo() {
      if (!adminMode) return;
      if (!redoStack.length) return;
      let nxt = redoStack.pop();
      let cur = JSON.parse(
        JSON.stringify({
          lines,
          startYear,
          startWeek,
          endYear,
          endWeek,
          lineCounter,
          barCounter,
          cellWidth,
          rowHeight,
          typeColors,
          currentTheme,
        })
      );
      undoStack.push(cur);
      restoreState(nxt);
    }

    const undoBtn = document.getElementById("undoBtn");
    undoBtn.addEventListener("click", undo);
    const redoBtn = document.getElementById("redoBtn");
    redoBtn.addEventListener("click", redo);

    /*
      ---------------------------------------------------------------------------------------------
      Timescale => set 10 years from start
      ---------------------------------------------------------------------------------------------
    */
    function checkTimescale() {
      let ds = toAbsoluteWeek(startYear, startWeek);
      let de = toAbsoluteWeek(endYear, endWeek);
      if (ds > de) {
        alert("Error: The Start date is later than the End date.");
        return false;
      }
      return true;
    }
    function timescaleChange() {
      startYear = parseInt(startYearInput.value) || 2025;
      startWeek = parseInt(startWeekInput.value) || 1;
      endYear = startYear + 10; 
      endWeek = 52;
      if (checkTimescale()) {
        pushState();
        renderTable();
        saveToLocalStorage();
      }
    }
    const startYearInput = document.getElementById("startYearInput");
    const startWeekInput = document.getElementById("startWeekInput");
    startYearInput.addEventListener("change", timescaleChange);
    startWeekInput.addEventListener("change", timescaleChange);

    /*
      ---------------------------------------------------------------------------------------------
      INIT => on window load => set up everything
      ---------------------------------------------------------------------------------------------
    */
    const tableWrapper = document.getElementById("tableWrapper");
    const ganttTable = document.getElementById("ganttTable");
    const tableBody = document.getElementById("tableBody");

    // Additional references for secondary sort
    const sortFieldSelect2 = document.getElementById("sortFieldSelect2");
    const sortDirectionSelect2 = document.getElementById("sortDirectionSelect2");

    // We remove the Apply Sort button => so we listen to sort field/direction changes instantly
    const sortFieldSelect = document.getElementById("sortFieldSelect");
    const sortDirectionSelect = document.getElementById("sortDirectionSelect");

    // Whenever user changes the sort field or direction, re-render immediately
    sortFieldSelect.addEventListener("change", () => {
      barSortField = sortFieldSelect.value;
      renderTable();
    });
    sortDirectionSelect.addEventListener("change", () => {
      barSortDirection = sortDirectionSelect.value;
      renderTable();
    });
    // Secondary sort events
    sortFieldSelect2.addEventListener("change", () => {
      barSortField2 = sortFieldSelect2.value;
      renderTable();
    });
    sortDirectionSelect2.addEventListener("change", () => {
      barSortDirection2 = sortDirectionSelect2.value;
      renderTable();
    });

    function init() {
      loadFromLocalStorage();    // Load previous user data
      populateDateSelects();     // Populate the bar date select fields
      updateCSSVariables();      // Sync CSS vars
      updateLegendSwatches();    // Reflect color swatches

      startYearInput.value = startYear; // Preload
      startWeekInput.value = startWeek;
      endYear = startYear + 10;
      endWeek = 52;

      zoomSlider.value = cellWidth;        // Sync slider
      heightZoomSlider.value = rowHeight;  // Sync slider

      themeSelect.value = currentTheme;    // Sync theme
      securedColor.value = typeColors.secured;
      proposedColor.value = typeColors.proposed;
      opportunityColor.value = typeColors.opportunity;
      futureColor.value = typeColors.future;

      populateSlicers(); // Fill slicer dropdowns
      applyTheme();       // Apply theme
      renderTable();      // Draw the Gantt
      pushState();        // Initial push to undo stack

      addItemsGroup.style.display = "none"; // Hide admin funcs by default

      // Recenter bar text on scroll or window resize
      tableWrapper.addEventListener("scroll", () => updateBarTextPositions());
      window.addEventListener("resize", () => updateBarTextPositions());
    }
    window.addEventListener("load", init);

    /*
      Populate the date selects for bar editor => year 2023..2040, weeks 1..52
    */
    function populateDateSelects() {
      let years = [];
      for (let y = 2023; y <= 2040; y++) {
        years.push(y);
      }
      let weeks = [];
      for (let w = 1; w <= 52; w++) {
        weeks.push(w);
      }
      [startYearSelect, endYearSelect].forEach((sel) => {
        sel.innerHTML = "";
        years.forEach((Y) => {
          let opt = document.createElement("option");
          opt.value = Y;
          opt.textContent = Y;
          sel.appendChild(opt);
        });
      });
      [startWeekSelect, endWeekSelect].forEach((sel) => {
        sel.innerHTML = "";
        weeks.forEach((W) => {
          let opt = document.createElement("option");
          opt.value = W;
          opt.textContent = W;
          sel.appendChild(opt);
        });
      });
    }

    /*
      parseCsv => minimal CSV parser for the import and text area
    */
    function parseCsv(csvString) {
      let linesArr = csvString.split(/\r?\n/);
      if (!linesArr.length) return { lines: [], lineCounter: 0, barCounter: 0 };
      let header = linesArr[0].split(",");
      linesArr.shift();
      let data = [];
      linesArr.forEach((row) => {
        if (!row.trim()) return;
        let cols = splitCsvRow(row);
        let entry = {};
        for (let i = 0; i < header.length; i++) {
          entry[header[i].trim()] = (cols[i] || "").trim();
        }
        data.push(entry);
      });
      let rebuilt = {};
      let lineCount = 0,
        barCount = 0;
      data.forEach((r) => {
        let lineId = r["Line ID"] || "";
        if (!rebuilt[lineId]) {
          rebuilt[lineId] = {
            id: parseInt(lineId) || 1000 + Object.keys(rebuilt).length,
            name: stripQuotes(r["Line Name"] || ""),
            client: stripQuotes(r["Line Client"] || ""),
            discipline: stripQuotes(r["Line Discipline"] || ""),
            experience: stripQuotes(r["Line Experience"] || ""),
            officeLocation: stripQuotes(r["Line OfficeLocation"] || ""),
            geoLocation: stripQuotes(r["Line GeoLocation"] || ""),
            type: stripQuotes(r["Line Type"] || ""),
            bars: [],
            selected: false,
            dragging: false,
          };
          lineCount++;
        }
        let barId = r["Bar ID"] || "";
        if (barId.trim()) {
          let sy = parseInt(r["Start Year"] || "2025");
          let sw = parseInt(r["Start Week"] || "1");
          let ey = parseInt(r["End Year"] || "2025");
          let ew = parseInt(r["End Week"] || "1");
          let startAbs = toAbsoluteWeek(sy, sw);
          let endAbs = toAbsoluteWeek(ey, ew);
          let length = endAbs - startAbs + 1;
          if (length < 1) length = 1;
          rebuilt[lineId].bars.push({
            id: parseInt(barId) || 9999 + barCount,
            label: stripQuotes(r["Bar Label"] || ""),
            projectName: stripQuotes(r["Project Name"] || ""),
            client: stripQuotes(r["Client"] || ""),
            discipline: stripQuotes(r["Discipline"] || ""),
            experience: stripQuotes(r["Experience"] || ""),
            LOE: stripQuotes(r["LOE"] || ""),
            location: stripQuotes(r["Location"] || ""),
            assignedTo: stripQuotes(r["Assigned to"] || ""),
            proposed: stripQuotes(r["Proposed"] || "no").toLowerCase(),
            type: stripQuotes(r["Type"] || "proposed").toLowerCase(),
            startAbsWeek: startAbs,
            length,
            selected: false,
            dragging: false,
          });
          barCount++;
        }
      });
      let finalLines = Object.values(rebuilt);
      return { lines: finalLines, lineCounter: lineCount, barCounter: barCount };
    }
    // Utility => properly handle quoted fields
    function splitCsvRow(row) {
      let result = [];
      let cur = "";
      let inQuotes = false;
      for (let i = 0; i < row.length; i++) {
        let c = row[i];
        if (c === '"') {
          inQuotes = !inQuotes;
          cur += c;
        } else if (c === "," && !inQuotes) {
          result.push(cur);
          cur = "";
        } else {
          cur += c;
        }
      }
      result.push(cur);
      return result;
    }
    // Remove outer quotes if present
    function stripQuotes(str) {
      return str.replace(/^"(.*)"$/, "$1");
    }
  </script>
</body>
</html>
