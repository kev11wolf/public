<!DOCTYPE html> <!-- Defines the document type as HTML5 -->
<html lang="en"> <!-- Sets the language of the page to English -->
<head> <!-- Head section: contains metadata and references -->
  <meta charset="UTF-8" /> <!-- Specifies the character encoding for the document -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/> <!-- Sets the viewport for responsive design -->
  <title>P6 Offline Viewer (Spin-off)</title> <!-- Page title -->

  <!-- Bootstrap 5 CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
  /> <!-- Links to the Bootstrap CSS for styling -->

  <!-- PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script> <!-- Links to PapaParse library to handle CSV data -->

  <!-- Bootstrap Icons (for optional icons, e.g. About icon) -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css"
  /> <!-- Links to Bootstrap Icons for various icon usage -->

  <style>
    /* 
      Neutral light theme with improved dark mode.
      Adjusted root variables to a more neutral palette
      and updated dark-mode variables to be deeper.
    */
    :root {
      /* Primary palette for light mode */
      --primary-color: #222831;   /* Dark neutral for navbar */
      --secondary-color: #393E46; /* Secondary neutral gray */
      --accent-color: #9CA3AF;    /* Subtle accent gray */
      --bg-color: #EEEEEE;        /* Light neutral background */
      --white-color: #FFFFFF;     /* White elements */
      
      /* Deeper dark mode colors for better contrast */
      --dark-background: #121212;       /* Main background */
      --dark-card-bg: #1E1E1E;          /* Card components */
      --dark-text-color: #E0E0E0;       /* Text color in dark mode */
      --hover-color: #E5E7EB;           /* Light mode row hover color */
    }

    /* 
      Expanded dark mode styling with stronger contrasts.
      .dark-mode class toggles these overrides.
    */
    body.dark-mode {
      background-color: var(--dark-background);
      color: var(--dark-text-color);
    }
    body.dark-mode .navbar {
      background-color: var(--dark-card-bg) !important;
    }
    body.dark-mode .card {
      background-color: var(--dark-card-bg) !important;
      color: var(--dark-text-color) !important;
    }
    body.dark-mode .table-hover tbody tr:hover {
      background-color: #333 !important; /* Darker row hover */
    }
    body.dark-mode .table-light {
      background-color: #2C2C2C !important;
      color: var(--dark-text-color) !important;
    }
    body.dark-mode .spinner-border.text-secondary {
      color: var(--dark-text-color) !important;
    }
    body.dark-mode .bg-primary,
    body.dark-mode .bg-warning,
    body.dark-mode .bg-success,
    body.dark-mode .bg-info,
    body.dark-mode .bg-dark {
      background-color: #2C2C2C !important;
      color: var(--dark-text-color) !important;
    }
    body.dark-mode .btn,
    body.dark-mode .btn-sm {
      color: var(--dark-text-color) !important;
    }
    body.dark-mode .activity-card:hover {
      background-color: #333 !important;
    }

    /*
      Base body styling in light mode with
      transitions for color or background changes.
    */
    body {
      background-color: var(--bg-color);
      font-size: 0.9rem;
      transition: background-color 0.2s ease, color 0.2s ease;
    }

    /* Navbar in light mode (dark neutral background). */
    .navbar {
      margin-bottom: 1rem;
      background-color: var(--primary-color) !important;
    }
    .navbar-brand {
      color: var(--white-color) !important;
    }

    /* Card styling: 90% width, shadow, light background. */
    .card {
      width: 90vw;
      margin: 0 auto;
      margin-bottom: 1rem;
      border: none;
      border-radius: 8px;
      transition: background-color 0.2s ease, color 0.2s ease;
    }
    .card-body {
      padding: 0.75rem;
      background-color: var(--white-color);
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
      transition: background-color 0.2s ease, color 0.2s ease;
    }
    .card-header {
      padding: 0.5rem 0.75rem;
      font-size: 0.9rem;
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      transition: background-color 0.2s ease, color 0.2s ease;
    }

    /* Log container for messages or tips. */
    .log-container {
      max-height: 150px;
      overflow-y: auto;
      background: #f1f1f1;
      padding: 8px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 0.8rem;
    }

    /* Hover effect for activity cards in list. */
    .activity-card {
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .activity-card:hover {
      background-color: var(--hover-color);
    }

    /* Subtle hover effect for buttons, inputs. */
    .btn:hover,
    .filter-input:hover {
      opacity: 0.95;
    }

    /* Container for search results. */
    .search-results {
      max-height: 200px;
      overflow-y: auto;
    }

    /* 
      Predecessor/Successor tables share .relation-table class.
      Adjusted column widths: 50px for all except column 2 (Name) = 200px.
    */
    .relation-table {
      table-layout: fixed;
      width: 100%;
      max-width: 100%;
      cursor: pointer;
    }
    .relation-table th,
    .relation-table td {
      font-size: 0.8rem;
      padding: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      transition: background-color 0.2s ease;
    }
    .relation-table th:nth-child(1),
    .relation-table td:nth-child(1) {
      width: 50px;
    }
    .relation-table th:nth-child(2),
    .relation-table td:nth-child(2) {
      width: 200px;
    }
    .relation-table th:nth-child(3),
    .relation-table td:nth-child(3) {
      width: 50px;
    }
    .relation-table th:nth-child(4),
    .relation-table td:nth-child(4) {
      width: 50px;
    }
    .relation-table th:nth-child(5),
    .relation-table td:nth-child(5) {
      width: 50px;
    }
    .relation-table th:nth-child(6),
    .relation-table td:nth-child(6) {
      width: 50px;
    }
    .relation-table th:nth-child(7),
    .relation-table td:nth-child(7) {
      width: 50px;
    }
    .relation-table th:nth-child(8),
    .relation-table td:nth-child(8) {
      width: 50px;
    }

    /* Filter inputs within the Predecessor/Successor detail card. */
    .filter-input {
      width: 100%;
      margin-bottom: 6px;
      font-size: 0.8rem;
    }

    /* CSV loading spinner hidden by default. */
    #csvLoadingSpinner {
      display: none;
    }

    /* Color classes for specific Activity Types. */
    .type-start-milestone,
    .type-finish-milestone,
    .type-loe {
      background-color: #d3d3d3 !important; /* Light grey highlight for these types */
    }
    .type-task-dependent {
      background-color: #d2f2d2 !important; /* Light green highlight for task-dependent */
    }
  </style> <!-- End of internal style block -->
</head> <!-- End of head section -->

<body> <!-- Body section starts -->

  <!-- Navigation bar -->
  <nav
    class="navbar navbar-expand-lg navbar-dark"
    style="background-color: var(--primary-color);"
  >
    <div class="container-fluid"> <!-- Wrapper for navbar content -->
      <!-- Inline SVG as logo -->
      <svg
        style="max-height: 40px; margin-right: 8px;"
        viewBox="0 0 24 24"
        fill="white"
        xmlns="http://www.w3.org/2000/svg"
      >
        <!-- Simple calendar-like icon -->
        <path
          d="M19 3H18V1H16V3H8V1H6V3H5C3.897 3 3 3.897 3 5V21C3 22.103 3.897 23 5 23H19C20.103 23 21 22.103 21 21V5C21 3.897 20.103 3 19 3ZM19 21H5V8H19V21Z"
        />
      </svg>
      <span class="navbar-brand" style="padding-top: 0;">P6 Offline Viewer</span>
      <!-- Brand name/title in the navbar -->

      <div class="ms-auto d-flex align-items-center">
        <!-- Right-aligned buttons -->
        <button id="aboutBtn" class="btn btn-secondary btn-sm me-2">
          <i class="bi bi-info-circle"></i>
          About
        </button> <!-- Button to show an About alert -->

        <button id="darkModeBtn" class="btn btn-danger btn-sm">
          Dark Mode
        </button> <!-- Button to toggle dark mode -->
      </div>
    </div>
  </nav>

  <!-- 
    Single row/column layout for main content. Cards are 90% wide.
    Changed from "display:none;" to "visibility:hidden;" to preserve layout.
    This ensures the page doesn't shift when toggling visibility.
  -->
  <div class="row g-3">
    <div class="col-12">
      <!-- 1) Upload Section -->
      <div class="card shadow-sm">
        <div class="card-header bg-primary text-white">
          <h6 class="mb-0">1. Upload Schedule (CSV)</h6>
        </div>
        <div class="card-body">
          <!-- File input for CSV upload -->
          <input
            type="file"
            id="csvUpload"
            accept=".csv"
            class="form-control form-control-sm"
            aria-label="Upload your schedule CSV file here to begin"
          />
          <small class="text-muted">
            Headers: Activity ID, Activity Name, Start, Finish, Predecessors, Predecessor Details...
          </small>
          <!-- Spinner displayed while CSV is parsing -->
          <div id="csvLoadingSpinner" class="text-center my-2">
            <div class="spinner-border text-secondary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <p class="small text-muted">Parsing CSV data...</p>
          </div>
        </div>
      </div>
      <!-- End Upload Section -->

      <!-- 2) Search for an Activity 
           visibility set to hidden so the layout remains stable 
      -->
      <div class="card shadow-sm" id="searchSection" style="visibility:hidden;">
        <div class="card-header bg-success text-white">
          <h6 class="mb-0">2. Search for an Activity</h6>
        </div>
        <div class="card-body">
          <!-- Search box for activities -->
          <input
            type="text"
            id="activitySearch"
            class="form-control form-control-sm mb-2"
            placeholder="Search ID or Name..."
            aria-label="Search activities by ID or name"
          />
          <!-- Populated with matching activities -->
          <div id="searchResults" class="search-results border p-2 bg-white small"></div>
        </div>
      </div>
      <!-- End Search Section -->

      <!-- 3) Critical Path Tracer Card 
           also set to visibility:hidden by default 
      -->
      <div class="card shadow-sm" id="cpTracer" style="visibility:hidden;">
        <div class="card-header bg-info text-white">
          <h6 class="mb-0">3. Critical Path Tracer</h6>
        </div>
        <div class="card-body">
          <!-- Table for showing the critical path array -->
          <table class="table table-sm table-hover" id="cpTable">
            <thead class="table-light">
              <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Start</th>
                <th>Finish</th>
                <th>Total Float</th>
                <th></th> <!-- remove button column -->
              </tr>
            </thead>
            <tbody id="cpTableBody"></tbody> <!-- CP Rows appended here -->
          </table>

          <!-- Buttons to manage the critical path array -->
          <button id="clearCPBtn" class="btn btn-warning btn-sm">Clear CP</button>
          <button id="resetCPBtn" class="btn btn-secondary btn-sm">Reset to Start</button>
        </div>
      </div>
      <!-- End CP Tracer Card -->

      <!-- 4) Predecessors & Successors 
           also hidden to preserve layout
      -->
      <div class="card shadow-sm" id="detailSection" style="visibility:hidden;">
        <div class="card-header bg-warning text-dark">
          <h6 class="mb-0">4. View Predecessors & Successors</h6>
        </div>
        <div class="card-body">
          <!-- Predecessors -->
          <h6>Predecessors</h6>
          <input
            type="text"
            placeholder="Filter Predecessors..."
            class="filter-input"
            id="predFilter"
          />
          <!-- Populated with predecessor rows -->
          <div id="predecessorList"></div>

          <!-- Successors -->
          <h6 class="mt-3">Successors</h6>
          <input
            type="text"
            placeholder="Filter Successors..."
            class="filter-input"
            id="succFilter"
          />
          <!-- Populated with successor rows -->
          <div id="successorList"></div>
        </div>
      </div>
      <!-- End detailSection -->

      <!-- Log Card (remains at bottom) -->
      <div class="card shadow-sm" id="logCard">
        <div class="card-header bg-dark text-white">
          <h6 class="mb-0">Log</h6>
        </div>
        <div class="card-body p-0">
          <pre id="log" class="log-container m-0 p-2"></pre>
        </div>
      </div>
      <!-- End Log Card -->
    </div>
  </div>

  <!-- Bootstrap JS bundle -->
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
  ></script> <!-- Bootstrap JavaScript Bundle -->

  <script>
    // -------------------------------------------------------------------
    // Global Variables and DOM Element References
    // -------------------------------------------------------------------
    let activities = [];         // Will hold all parsed activities from the CSV
    let activityMap = {};        // Maps Activity ID -> activity object
    let selectedActivity = null; // Currently selected activity in the UI
    let criticalPath = [];       // Array for building the CP

    // Sorting states used for Predecessors/Successors table sorting
    // By default, we set the field to 'Finish' and asc=false to sort by latest finish date first.
    let sortState = {
      pred: { field: 'Finish', asc: false },
      succ: { field: 'Finish', asc: false }
    };

    // References to DOM elements used throughout
    const csvUpload = document.getElementById('csvUpload'); 
    const searchSection = document.getElementById('searchSection');
    const detailSection = document.getElementById('detailSection');
    const cpTracer = document.getElementById('cpTracer');
    const activitySearch = document.getElementById('activitySearch');
    const searchResults = document.getElementById('searchResults');
    const predecessorList = document.getElementById('predecessorList');
    const successorList = document.getElementById('successorList');
    const predFilter = document.getElementById('predFilter');
    const succFilter = document.getElementById('succFilter');
    const log = document.getElementById('log');
    const csvLoadingSpinner = document.getElementById('csvLoadingSpinner');
    const cpTableBody = document.getElementById('cpTableBody');
    const clearCPBtn = document.getElementById('clearCPBtn');
    const resetCPBtn = document.getElementById('resetCPBtn');
    const aboutBtn = document.getElementById('aboutBtn');
    const darkModeBtn = document.getElementById('darkModeBtn');

    // -------------------------------------------------------------------
    // Utility / Logging / Date parsing
    // -------------------------------------------------------------------

    /**
     * Adds a message to the log container, with optional TIP text.
     * @param {string} message - Main log message
     * @param {string} tip - Optional tip or advice
     */
    function addLog(message, tip = '') {
      const timestamp = new Date().toLocaleTimeString();
      const logLine = tip
        ? `[${timestamp}] ${message}\n TIP: ${tip}\n`
        : `[${timestamp}] ${message}\n`;
      log.innerHTML += logLine;
      // Auto-scroll to bottom
      log.scrollTop = log.scrollHeight;
    }

    /**
     * Cleans date strings from CSV (e.g. removing " A" or "*") 
     * @param {string} dateStr - Raw date from CSV
     * @returns {string} - Cleaned date string
     */
    function cleanDate(dateStr) {
      if (!dateStr) return '';
      return dateStr.toString().replace(/ A/g, '').replace(/\*/g, '').trim();
    }

    /**
     * Parses a date string into a JS Date object; returns null if invalid.
     * @param {string} dateStr 
     * @returns {Date|null} - Valid Date object or null
     */
    function parseDate(dateStr) {
      if (!dateStr) return null;
      const d = new Date(dateStr);
      return isNaN(d.getTime()) ? null : d;
    }

    /**
     * Checks if required columns are present in the CSV's first set of data.
     * @param {Array} data - Parsed CSV data array
     * @returns {boolean} - True if all required columns exist
     */
    function validateColumns(data) {
      const requiredColumns = [
        'Activity ID',
        'Start',
        'Finish',
        'Predecessors',
        'Predecessor Details'
      ];
      if (data.length === 0) {
        addLog('No data found in CSV.', 'Please check your file and try again.');
        alert('CSV is empty. Please upload a valid file.');
        return false;
      }
      const firstRow = Object.keys(data[0]);
      const missingColumns = requiredColumns.filter(col => !firstRow.includes(col));
      if (missingColumns.length > 0) {
        addLog(
          'Missing columns: ' + missingColumns.join(', '),
          'Make sure CSV has all required columns.'
        );
        alert('Some required columns are missing: ' + missingColumns.join(', '));
        return false;
      }
      return true;
    }

    /**
     * Finds relationship type by scanning "Predecessor Details" 
     * for the matching activity ID.
     * @param {Object} sourceAct - The referencing / current activity
     * @param {string} targetID  - The ID of the potential predecessor or successor
     * @returns {string} - Relationship type (e.g. FS, FF, etc.) or dash if not found
     */
    function parseRelationshipType(sourceAct, targetID) {
      const detailStr = sourceAct['Predecessor Details'] || '';
      const chunks = detailStr.split(';').map(x => x.trim()).filter(Boolean);
      for (const c of chunks) {
        const parts = c.split(':').map(x => x.trim());
        if (parts.length >= 2) {
          const pID = parts[0];
          const rel = parts[1];
          if (pID === targetID) {
            return rel;
          }
        }
      }
      return '—';
    }

    /**
     * Sorts an array of activities by the chosen field, ascending or descending.
     * Handles numeric, date, and string comparisons.
     * @param {Array} arr - Activity list
     * @param {string} field - Field name (e.g. "Total Float", "Start", "Finish")
     * @param {boolean} ascending - Direction of sort
     */
    function sortActivities(arr, field, ascending) {
      arr.sort((a, b) => {
        const valA = (a[field] || '').toLowerCase();
        const valB = (b[field] || '').toLowerCase();

        // Numeric float case:
        if (field === 'Total Float') {
          const numA = parseFloat(valA) || 0;
          const numB = parseFloat(valB) || 0;
          return ascending ? numA - numB : numB - numA;
        }
        // Date fields:
        if (field === 'Start' || field === 'Finish') {
          const dateA = parseDate(valA) || 0;
          const dateB = parseDate(valB) || 0;
          return ascending ? dateA - dateB : dateB - dateA;
        }
        // Default string comparison:
        if (valA < valB) return ascending ? -1 : 1;
        if (valA > valB) return ascending ? 1 : -1;
        return 0;
      });
    }

    /**
     * Filters an array of activities by substring match against any field.
     * @param {Array} arr - Array of activity objects
     * @param {string} query - Search query
     * @returns {Array} - Filtered subset
     */
    function filterActivities(arr, query) {
      if (!query) return arr;
      const q = query.toLowerCase();
      return arr.filter(act => {
        return Object.values(act).some(val => {
          if (!val) return false;
          return val.toString().toLowerCase().includes(q);
        });
      });
    }

    /**
     * Returns a class name to color-code a row by activity type.
     * @param {string} actType
     * @returns {string} - CSS class name or empty
     */
    function getRowClassByType(actType) {
      if (!actType) return '';
      const lower = actType.toLowerCase();
      if (
        lower.includes('start milestone') ||
        lower.includes('finish milestone') ||
        lower.includes('loe')
      ) {
        return 'type-loe'; 
      }
      if (lower.includes('task dependent')) {
        return 'type-task-dependent';
      }
      return '';
    }

    /**
     * Returns a background color for the float cell based on range.
     * Creates a white-to-red gradient if multiple float values exist.
     * @param {string|number} tf 
     * @param {number} minTF 
     * @param {number} maxTF 
     * @returns {string} - CSS color or empty string
     */
    function getFloatShading(tf, minTF, maxTF) {
      if (minTF === maxTF) {
        // No gradient if only one float value
        return '';
      }
      const val = parseFloat(tf);
      if (isNaN(val)) return '';

      // ratio from 0..1
      let ratio = (val - minTF) / (maxTF - minTF);
      // Invert so smaller float => more red
      ratio = 1 - ratio;

      // White => red gradient attempt
      const R = 255; 
      const G = Math.floor(255 - 255 * ratio);
      const B = Math.floor(255 - 255 * ratio);

      return `rgb(${R}, ${G}, ${B}, 0.7)`;
    }

    // -------------------------------------------------------------------
    // CSV Upload and Parsing
    // -------------------------------------------------------------------
    csvUpload.addEventListener('change', (e) => {
      // Triggered when user selects a CSV file
      const file = e.target.files[0];
      if (!file) return;

      addLog(`File selected: ${file.name}`, 'Wait for parsing, then search for an activity.');
      csvLoadingSpinner.style.display = 'block'; // Show spinner

      // Parse CSV with PapaParse
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        worker: true,
        complete: (result) => {
          csvLoadingSpinner.style.display = 'none'; // Hide spinner

          if (result.errors.length) {
            // If parse errors exist, log them
            addLog(
              `Parse errors: ${result.errors.map(er => er.message).join('; ')}`,
              'Check CSV format or try another file.'
            );
            alert('CSV parsing failed. Check log.');
            return;
          }

          // Validate the presence of required columns
          if (!validateColumns(result.data)) return;

          // Clean up date fields
          activities = result.data.map(act => ({
            ...act,
            'Start': cleanDate(act['Start']),
            'Finish': cleanDate(act['Finish'])
          }));

          // Build ID->activity map for quick lookups
          activityMap = {};
          activities.forEach(act => {
            const rawID = act['Activity ID'] ? act['Activity ID'] : '';
            const id = rawID.trim();
            if (id) {
              activityMap[id] = act;
            }
          });

          addLog(`Loaded ${activities.length} activities.`, 'Search for an Activity in Step 2.');

          // Show search section, keep CP and details hidden, but without affecting layout
          // Old code with display:
          //   searchSection.style.display = 'block';
          //   cpTracer.style.display = 'none';
          //   detailSection.style.display = 'none';
          // Replaced with visibility to avoid layout shift:
          searchSection.style.visibility = 'visible';
          cpTracer.style.visibility = 'hidden';
          detailSection.style.visibility = 'hidden';
        },
        error: (err) => {
          // PapaParse parse error
          csvLoadingSpinner.style.display = 'none';
          addLog(`Parse error: ${err}`, 'Check your CSV file and try again.');
          alert('Failed to parse CSV.');
        }
      });
    });

    // -------------------------------------------------------------------
    // Searching for Activities
    // -------------------------------------------------------------------
    activitySearch.addEventListener('input', () => {
      // As user types, filter the list of activities
      const query = activitySearch.value.trim().toLowerCase();
      searchResults.innerHTML = ''; // Clear old matches
      if (!query) return;

      // Filter by ID or Name
      const matches = activities.filter(act => {
        const id = act['Activity ID'] ? act['Activity ID'].toLowerCase() : '';
        const name = act['Activity Name'] ? act['Activity Name'].toLowerCase() : '';
        return (id.includes(query) || name.includes(query));
      });

      if (matches.length === 0) {
        searchResults.innerHTML = '<div class="text-muted p-1">No activities found.</div>';
        return;
      }

      // Build a list of clickable results
      matches.forEach(act => {
        const div = document.createElement('div');
        div.className = 'activity-card p-1 border-bottom small';
        const idVal = act['Activity ID'] || 'N/A';
        const nameVal = act['Activity Name'] || 'N/A';
        // Show ID and Name
        div.innerHTML = `<strong>${idVal}</strong> - ${nameVal}`;
        // On click => select that activity
        div.onclick = () => selectActivity(act);
        searchResults.appendChild(div);
      });

      addLog(
        `Search results updated for "${query}".`,
        'Click an activity to begin building a CP and see Predecessors/Successors.'
      );
    });

    // -------------------------------------------------------------------
    // Selecting an Activity
    // -------------------------------------------------------------------
    function selectActivity(act) {
      // Called when user clicks a search result or double-clicks a table row
      selectedActivity = act;
      addLog(
        `Activity selected: ${act['Activity ID']}`,
        'You can now see and sort Predecessors/Successors, and manage the CP.'
      );

      // Clear search UI
      activitySearch.value = '';
      searchResults.innerHTML = '';

      // Reset CP to just this activity
      criticalPath = [act];
      updateCPUI();

      // Show all sections via visibility to keep layout consistent
      // Old code using display:
      //   searchSection.style.display = 'block';
      //   cpTracer.style.display = 'block';
      //   detailSection.style.display = 'block';
      searchSection.style.visibility = 'visible';
      cpTracer.style.visibility = 'visible';
      detailSection.style.visibility = 'visible';

      // Load Predecessors & Successors
      showPredecessors(act);
      showSuccessors(act);
    }

    // -------------------------------------------------------------------
    // Critical Path Tracer Logic
    // -------------------------------------------------------------------
    /**
     * Refreshes the Critical Path (CP) table in the UI.
     */
    function updateCPUI() {
      cpTableBody.innerHTML = ''; // Clear existing rows
      criticalPath.forEach((cpAct, idx) => {
        const tr = document.createElement('tr');

        // Extract relevant fields
        const idVal = cpAct['Activity ID'] || '—';
        const nameVal = cpAct['Activity Name'] || '—';
        const startVal = cpAct['Start'] || '—';
        const finishVal = cpAct['Finish'] || '—';
        const tfVal = cpAct['Total Float'] || '—';

        // Build row
        tr.innerHTML = `
          <td><strong>${idVal}</strong></td>
          <td>${nameVal}</td>
          <td>${startVal}</td>
          <td>${finishVal}</td>
          <td>${tfVal}</td>
          <td>
            <!-- Inline button to remove from CP -->
            <button class="btn btn-sm btn-outline-danger" onclick="removeFromCP(${idx})"> X </button>
          </td>
        `;

        // Color-code by "Activity Type" (if any)
        const actType = (cpAct['Activity Type'] || '').toLowerCase();
        const rowClass = getRowClassByType(actType);
        if (rowClass) {
          tr.classList.add(rowClass);
        }

        cpTableBody.appendChild(tr);
      });
    }

    /**
     * Removes an entry from the CP array given its index.
     * @param {number} index - Index in the criticalPath array
     */
    window.removeFromCP = (index) => {
      const removed = criticalPath.splice(index, 1);
      addLog(`Removed from CP: ${removed[0]['Activity ID']}`);
      updateCPUI();
    };

    // Clear the entire CP
    clearCPBtn.addEventListener('click', () => {
      criticalPath = [];
      addLog('Cleared entire CP.', 'Re-select an activity or Reset if needed.');
      updateCPUI();
    });

    // Reset CP to original selected activity
    resetCPBtn.addEventListener('click', () => {
      if (selectedActivity) {
        criticalPath = [selectedActivity];
        addLog('Reset CP to initial activity.', 'You can explore Predecessors again.');
        updateCPUI();
      }
    });

    // -------------------------------------------------------------------
    // Show Predecessors
    // -------------------------------------------------------------------
    function showPredecessors(currentAct) {
      // Clear old display
      predecessorList.innerHTML = '';

      // Gather raw predecessor IDs from CSV field
      const rawPreds = (currentAct['Predecessors'] || '')
        .split(/[,;]/)
        .map(s => s.trim())
        .filter(Boolean);

      // Only use valid IDs that exist in activityMap
      let validPreds = rawPreds.filter(id => activityMap[id]);
      if (validPreds.length === 0) {
        predecessorList.innerHTML = '<p class="text-muted small">No predecessors.</p>';
        return;
      }

      // Convert IDs to actual activity objects
      let predArray = validPreds.map(pid => activityMap[pid]);

      // Filter by user input
      const filterVal = predFilter.value.trim().toLowerCase();
      predArray = filterActivities(predArray, filterVal);

      // Sort the list by the stored sort state (Finish date descending by default)
      const field = sortState.pred.field;
      const asc = sortState.pred.asc;
      sortActivities(predArray, field, asc);

      // Compute min/max total float for coloring
      let floats = predArray.map(p => parseFloat(p['Total Float']) || 0);
      const minTF = Math.min(...floats);
      const maxTF = Math.max(...floats);

      // Build table structure
      const table = document.createElement('table');
      table.className = 'table table-sm table-bordered relation-table table-hover';
      table.innerHTML = `
        <thead class="table-light">
          <tr>
            <th data-col="Activity ID">ID <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Activity Name">Name <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Start">Start <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Finish">Finish <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Primary Constraint">Primary Constraint <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Total Float">Total Float <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Activity Type">Activity Type <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Relationship Type">Relationship Type <i class="bi bi-arrows-expand"></i></th>
          </tr>
        </thead>
        <tbody id="predTableBody"></tbody>
      `;
      const tbody = table.querySelector('#predTableBody');

      // Create table rows for each predecessor
      predArray.forEach(predAct => {
        const row = document.createElement('tr');
        row.className = 'activity-card';

        // Double-click => re-select that predecessor as current
        row.ondblclick = () => selectActivity(predAct);

        // SHIFT-click was removed per request, so no "add to CP" here

        // Pull relevant fields for display
        const idVal = predAct['Activity ID'] || '—';
        const nameVal = predAct['Activity Name'] || '—';
        const startVal = predAct['Start'] || '—';
        const finishVal = predAct['Finish'] || '—';
        const pcVal = predAct['Primary Constraint'] || '—';
        const tfVal = predAct['Total Float'] || '—';
        const typeVal = predAct['Activity Type'] || '—';
        const relType = parseRelationshipType(currentAct, idVal);

        // Insert cells
        row.innerHTML = `
          <td><strong>${idVal}</strong></td>
          <td>${nameVal}</td>
          <td>${startVal}</td>
          <td>${finishVal}</td>
          <td>${pcVal}</td>
          <td>${tfVal}</td>
          <td>${typeVal}</td>
          <td>${relType}</td>
        `;

        // Color-code by type
        const rowClass = getRowClassByType(typeVal);
        if (rowClass) {
          row.classList.add(rowClass);
        }

        // Float shading
        const cellTF = row.querySelector('td:nth-child(6)');
        if (cellTF && tfVal !== '—') {
          cellTF.style.backgroundColor = getFloatShading(
            parseFloat(tfVal),
            minTF,
            maxTF
          );
        }

        tbody.appendChild(row);
      });

      // Append completed table
      predecessorList.appendChild(table);

      // Enable sorting on table headers
      const headers = table.querySelectorAll('th[data-col]');
      headers.forEach(th => {
        th.addEventListener('click', () => {
          const col = th.getAttribute('data-col');
          if (sortState.pred.field === col) {
            sortState.pred.asc = !sortState.pred.asc;
          } else {
            sortState.pred.field = col;
            sortState.pred.asc = true;
          }
          showPredecessors(currentAct);
        });
      });
    }

    // -------------------------------------------------------------------
    // Show Successors
    // -------------------------------------------------------------------
    function showSuccessors(currentAct) {
      // Clear old table, if any
      successorList.innerHTML = '';

      // Find all activities that have currentAct's ID in their "Predecessors" field
      const currentID = currentAct['Activity ID'] || '';
      const successors = activities.filter(act => {
        const rawPreds = (act['Predecessors'] || '')
          .split(/[,;]/)
          .map(s => s.trim());
        return rawPreds.includes(currentID);
      });

      if (successors.length === 0) {
        successorList.innerHTML = '<p class="text-muted small">No successors.</p>';
        return;
      }

      let succArray = successors;

      // Filter by user input
      const filterVal = succFilter.value.trim().toLowerCase();
      succArray = filterActivities(succArray, filterVal);

      // Sort by the stored state (Finish descending by default)
      const field = sortState.succ.field;
      const asc = sortState.succ.asc;
      sortActivities(succArray, field, asc);

      // Determine min & max float for coloring
      let floats = succArray.map(s => parseFloat(s['Total Float']) || 0);
      const minTF = Math.min(...floats);
      const maxTF = Math.max(...floats);

      // Build the table
      const table = document.createElement('table');
      table.className = 'table table-sm table-bordered relation-table table-hover';
      table.innerHTML = `
        <thead class="table-light">
          <tr>
            <th data-col="Activity ID">ID <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Activity Name">Name <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Start">Start <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Finish">Finish <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Primary Constraint">Primary Constraint <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Total Float">Total Float <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Activity Type">Activity Type <i class="bi bi-arrows-expand"></i></th>
            <th data-col="Relationship Type">Relationship Type <i class="bi bi-arrows-expand"></i></th>
          </tr>
        </thead>
        <tbody id="succTableBody"></tbody>
      `;
      const tbody = table.querySelector('#succTableBody');

      // Populate rows
      succArray.forEach(succAct => {
        const row = document.createElement('tr');
        row.className = 'activity-card';

        // Double-click => re-select as current
        row.ondblclick = () => selectActivity(succAct);

        // SHIFT-click removed, as requested

        const idVal = succAct['Activity ID'] || '—';
        const nameVal = succAct['Activity Name'] || '—';
        const startVal = succAct['Start'] || '—';
        const finishVal = succAct['Finish'] || '—';
        const pcVal = succAct['Primary Constraint'] || '—';
        const tfVal = succAct['Total Float'] || '—';
        const typeVal = succAct['Activity Type'] || '—';
        const relType = parseRelationshipType(succAct, currentID);

        row.innerHTML = `
          <td><strong>${idVal}</strong></td>
          <td>${nameVal}</td>
          <td>${startVal}</td>
          <td>${finishVal}</td>
          <td>${pcVal}</td>
          <td>${tfVal}</td>
          <td>${typeVal}</td>
          <td>${relType}</td>
        `;

        // Color by type
        const rowClass = getRowClassByType(typeVal);
        if (rowClass) {
          row.classList.add(rowClass);
        }

        // Apply float shading
        const cellTF = row.querySelector('td:nth-child(6)');
        if (cellTF && tfVal !== '—') {
          cellTF.style.backgroundColor = getFloatShading(
            parseFloat(tfVal),
            minTF,
            maxTF
          );
        }

        tbody.appendChild(row);
      });

      // Append the newly created table
      successorList.appendChild(table);

      // Implement header sorting
      const headers = table.querySelectorAll('th[data-col]');
      headers.forEach(th => {
        th.addEventListener('click', () => {
          const col = th.getAttribute('data-col');
          if (sortState.succ.field === col) {
            sortState.succ.asc = !sortState.succ.asc;
          } else {
            sortState.succ.field = col;
            sortState.succ.asc = true;
          }
          showSuccessors(currentAct);
        });
      });
    }

    // Trigger re-render upon filter input for Predecessors/Successors
    predFilter.addEventListener('input', () => {
      if (selectedActivity) showPredecessors(selectedActivity);
    });
    succFilter.addEventListener('input', () => {
      if (selectedActivity) showSuccessors(selectedActivity);
    });

    // -------------------------------------------------------------------
    // About / Dark Mode
    // -------------------------------------------------------------------
    aboutBtn.addEventListener('click', () => {
      // Simple usage instructions
      alert(
        "P6 Offline Viewer\n\n" +
        "1. Upload a CSV containing your schedule.\n" +
        "2. Search for an activity by ID or Name.\n" +
        "3. Build a CP in the 'Critical Path Tracer'.\n" +
        "4. Double-click any row to jump to that activity.\n" +
        "5. Filter or sort columns. Smaller Total Float is shaded more red.\n" +
        "6. Enjoy!"
      );
      addLog('Opened About info.');
    });

    darkModeBtn.addEventListener('click', () => {
      // Toggle body class to enable dark mode
      document.body.classList.toggle('dark-mode');
      addLog('Toggled Dark Mode.', 'Light <-> Dark theme switched.');
    });
  </script>
</body>
</html>
